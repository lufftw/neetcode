# 542. 01 Matrix

## Problem Link
https://leetcode.com/problems/01-matrix/

## Difficulty
Medium

## Tags
- Array
- Breadth-First Search
- Matrix
- Dynamic Programming

## Pattern
GridBFSMultiSource - Distance Field

## API Kernel
`GridBFSMultiSource`

## Problem Summary

Given an m × n binary matrix `mat`, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.

## Key Insight

This is a **distance field computation** problem. For each cell, we want the shortest distance to ANY zero. Multi-source BFS from all zeros computes this optimally:

1. All zeros have distance 0 (they ARE zeros)
2. Start BFS from all zeros simultaneously
3. First time a cell is reached = its minimum distance to any zero

```
Input:         Output:
0 0 0          0 0 0
0 1 0    →     0 1 0
1 1 1          1 2 1
```

## Delta from Base Template

| Aspect | Rotting Oranges | 01 Matrix |
|--------|-----------------|-----------|
| Source | Rotten (2) | Zero (0) |
| Target | Fresh (1) | One (1) |
| Output | Single value (time) | New matrix (distances) |
| Tracking | Count remaining | Distance matrix |

Key changes:
1. Create separate distance matrix (or modify in place)
2. Initialize zeros with distance 0
3. Initialize ones with infinity (or a sentinel like -1)

## Template Mapping

```python
from collections import deque
from typing import List

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        rows, cols = len(mat), len(mat[0])
        queue = deque()

        # Phase 1: Initialize distance matrix
        # Zeros have distance 0, ones start with infinity
        dist = [[0 if mat[r][c] == 0 else float('inf')
                 for c in range(cols)] for r in range(rows)]

        # Add all zeros to queue (sources at distance 0)
        for r in range(rows):
            for c in range(cols):
                if mat[r][c] == 0:
                    queue.append((r, c))

        # Phase 2: BFS from all zeros
        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        while queue:
            r, c = queue.popleft()

            for dr, dc in DIRECTIONS:
                nr, nc = r + dr, c + dc

                if 0 <= nr < rows and 0 <= nc < cols:
                    # Update if we found a shorter path
                    new_dist = dist[r][c] + 1
                    if new_dist < dist[nr][nc]:
                        dist[nr][nc] = new_dist
                        queue.append((nr, nc))

        return dist
```

## Alternative: In-Place Modification

```python
class SolutionInPlace:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        """
        Modify matrix in-place using -1 as 'unvisited one' marker.
        """
        rows, cols = len(mat), len(mat[0])
        queue = deque()

        # Mark all ones as unvisited (-1), add zeros to queue
        for r in range(rows):
            for c in range(cols):
                if mat[r][c] == 0:
                    queue.append((r, c))
                else:
                    mat[r][c] = -1  # Unvisited marker

        DIRECTIONS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        distance = 0

        while queue:
            distance += 1
            for _ in range(len(queue)):
                r, c = queue.popleft()

                for dr, dc in DIRECTIONS:
                    nr, nc = r + dr, c + dc

                    if 0 <= nr < rows and 0 <= nc < cols:
                        if mat[nr][nc] == -1:  # Unvisited one
                            mat[nr][nc] = distance
                            queue.append((nr, nc))

        return mat
```

## Complexity
- Time: O(m × n) - each cell visited at most once
- Space: O(m × n) - queue and distance matrix

## Why This Problem Third?

01 Matrix consolidates the pattern with a clean output specification:

1. **Pure distance field**: Output is a matrix of distances
2. **No special states**: Just 0s and 1s (cleaner than walls/gates)
3. **Guaranteed solvability**: Every cell is reachable from some zero
4. **Flexible implementation**: Can modify in-place or create new matrix

## Common Mistakes

1. **BFS from each one** - O(m²n²) vs O(mn) with multi-source from zeros
2. **Wrong initialization** - Ones must start as infinity/unvisited, not 1
3. **Confusing source vs target** - Sources are zeros (known distance), targets are ones
4. **Level counting off-by-one** - Zeros are at distance 0, not 1

## DP Alternative

This problem can also be solved with DP (two passes), but BFS is more intuitive for grid distance problems:

```python
# DP approach (for reference):
# Pass 1: top-left to bottom-right (check top and left)
# Pass 2: bottom-right to top-left (check bottom and right)
```

## Related Problems
- LC 994: Rotting Oranges (propagation timer)
- LC 286: Walls and Gates (similar fill pattern)
- LC 1162: As Far from Land as Possible (max min-distance)
- LC 934: Shortest Bridge (BFS between two islands)


