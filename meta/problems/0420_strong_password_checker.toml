# Problem: Strong Password Checker
# https://leetcode.com/problems/strong-password-checker/

# ===== Problem Info =====
id = "0420"
slug = "0420_strong_password_checker"
title = "Strong Password Checker"
leetcode_id = 420
url = "https://leetcode.com/problems/strong-password-checker/"

# ===== LeetCode Official Metadata =====
difficulty = "hard"
topics = ["string", "greedy", "heap"]
companies = ["google", "amazon"]

# ===== Roadmaps =====
roadmaps = []

# ===== Ontology Tags (Problem Level) =====
api_kernels      = []
patterns         = ["greedy_case_analysis", "string_validation"]
families         = ["string_processing", "constraint_optimization"]
data_structures  = ["array", "string"]
algorithms       = ["greedy"]
related_problems = ["0068", "0068"]  # Text Justification has similar case analysis

# ===== File Locations =====
[files]
solution  = "solutions/0420_strong_password_checker.py"
generator = "generators/0420_strong_password_checker.py"
tests_dir = "tests/"

# ===== Solutions =====
[[solutions]]
key    = "default"
class  = "Solution"
method = "strongPasswordChecker"

api_kernels      = []
patterns         = ["greedy_case_analysis"]
families         = ["constraint_optimization"]
data_structures  = ["array"]
algorithms       = ["greedy"]
related_problems = []

role       = "base"
variant    = ""
based_on   = []
delta      = ""
complexity = "O(n) time, O(n) space"
notes      = """
Three-case greedy algorithm based on password length:
1. Too short (n < 6): Insert chars that also fix missing types and break repeats
2. Valid length (6-20): Only replacements needed for repeats and missing types
3. Too long (n > 20): Strategic deletions prioritized by (L % 3) efficiency, then replacements

Key insight: For repeat sequences of length L, deletions have different efficiency:
- L % 3 == 0: 1 deletion saves 1 replacement (most efficient)
- L % 3 == 1: 2 deletions save 1 replacement
- L % 3 == 2: 3 deletions save 1 replacement
"""
