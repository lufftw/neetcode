<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Window & Two Pointers ‚Äì Unified Mastery Map - NeetCode Mind Maps</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        .markmap { width: 100%; height: 100%; }
        .markmap > svg { width: 100%; height: 100%; }
        #topbar {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            background: #fff; border-bottom: 1px solid #e5e7eb;
            padding: 8px 16px; display: flex; gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 13px;
        }
        #topbar button {
            padding: 4px 12px; border: 1px solid #d1d5db;
            border-radius: 4px; background: #fff; cursor: pointer;
        }
        #topbar button:hover { background: #f3f4f6; }
        .markmap { margin-top: 40px; height: calc(100% - 40px); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar"></script>
    <script>
        function fitView() {
            var svg = document.querySelector('.markmap > svg');
            if (svg && svg.mm) svg.mm.fit();
        }
        function expandAll() {
            var svg = document.querySelector('.markmap > svg');
            if (svg && svg.mm) {
                var root = svg.mm.state.data;
                (function expand(n) {
                    n.payload = Object.assign({}, n.payload, { fold: 0 });
                    if (n.children) n.children.forEach(expand);
                })(root);
                svg.mm.setData(root); svg.mm.fit();
            }
        }
        function collapseAll() {
            var svg = document.querySelector('.markmap > svg');
            if (svg && svg.mm) {
                var root = svg.mm.state.data;
                root.children && root.children.forEach(function collapse(n) {
                    if (n.children && n.children.length) {
                        n.payload = Object.assign({}, n.payload, { fold: 1 });
                        n.children.forEach(collapse);
                    }
                });
                svg.mm.setData(root); svg.mm.fit();
            }
        }
        document.addEventListener('DOMContentLoaded', function() {
            const { Transformer, Markmap } = window.markmap;
            const transformer = new Transformer();
            const markdown = `
# Sliding Window & Two Pointers ‚Äì Unified Mastery Map üéØ

## üî≠ 0. Big Picture

- **Core Idea**
  - Many "substring / subarray / pair / k-sum" problems reduce to:
    - Maintain **pointers** over a sequence
    - Maintain a small **state**
    - Maintain an **invariant** until goal is reached
- **API Kernels**
  - \`SubstringSlidingWindow\` ‚Üí 1D dynamic window, invariant on \`[L, R]\`
  - \`TwoPointersTraversal\` ‚Üí 2 pointers with structured movement
- **You will learn**
  - Patterns ‚Üí Templates ‚Üí Concrete LeetCode problems
  - When to pick:
    - Sliding window vs generic two pointers
    - Hash map vs prefix sum vs sorting
- **Roadmaps**
  - Sliding Window: \`sliding_window_path\`
  - Two Pointers: \`two_pointers_path\`
  - Interview sets: \`neetcode_150\`, \`blind_75\`, \`grind_75\`, \`leetcode_top_100\`

---

## üß† 1. API Kernel: \`SubstringSlidingWindow\`

- **Definition**
  - 1D window state machine over sequences with dynamic invariants
  - Always tracking a contiguous interval \`[left, right]\`
- **Key Properties**
  - Time: Typically \$O(n)\$
  - Space: Usually \$O(\sigma)\$ or \$O(K)\$ for maps/counters
  - Works when:
    - Answer is a **contiguous** substring/subarray
    - State can be updated in **O(1)** when expanding/shrinking

### 1.1 Core Template

\`\`\`python
left = 0
state = init_state()
answer = init_answer()

for right, x in enumerate(seq):
    add(state, x)              # EXPAND

    while invariant_violated(state):
        remove(state, seq[left])  # CONTRACT
        left += 1

    answer = update(answer, left, right, state)

return answer
\`\`\`

- Variants:
  - **Maximize window** (longest length)
  - **Minimize window** (shortest length)
  - **Fixed-size window** (length = k)

---

## üß© 2. Sliding Window Pattern Family

<!-- markmap: fold -->

### 2.1 Unique Characters Window (\`sliding_window_unique\`) üîë

- **Invariant**: All elements in window are unique
- **State**: \`last_seen_index\` or frequency map
- **Goal**: Maximize window length
- **Canonical Problem**
  - [LeetCode 3 - Longest Substring Without Repeating Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py) ‚úÖ
    - Topics: string, hash table, sliding window, two pointers
    - Roadmaps: \`neetcode_150\`, \`blind_75\`, \`grind_75\`, \`leetcode_top_100\`, \`sliding_window_path\`
- **Template Twist**
  - Use **jumping left** optimization via \`last_seen_index[char] + 1\` instead of while-loop

\`\`\`python
last_seen = {}
left = 0
best = 0

for right, ch in enumerate(s):
    if ch in last_seen and last_seen[ch] >= left:
        left = last_seen[ch] + 1
    last_seen[ch] = right
    best = max(best, right - left + 1)
\`\`\`

---

### 2.2 At Most K Distinct (\`sliding_window_at_most_k_distinct\`)

- **Invariant**: \`distinct_chars_in_window <= K\`
- **State**: \`Counter\` / map: char ‚Üí freq
- **Goal**: Maximize length
- **Representative Problem**
  - [LeetCode 340 - Longest Substring with At Most K Distinct Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
- **Key Point**
  - Need **while-loop** contraction; cannot jump because multiple chars may need to be removed

\`\`\`python
freq = {}
left = 0
best = 0

for right, ch in enumerate(s):
    freq[ch] = freq.get(ch, 0) + 1
    while len(freq) > k:
        freq[s[left]] -= 1
        if freq[s[left]] == 0:
            del freq[s[left]]
        left += 1
    best = max(best, right - left + 1)
\`\`\`

---

### 2.3 Frequency Cover / ‚ÄúHave vs Need‚Äù (\`sliding_window_freq_cover\`) üßÆ

- **Invariant**: Window has all required characters with required frequencies
- **State**
  - \`need\`: required frequencies from pattern
  - \`have\`: current window frequencies
  - \`have_satisfied\`: count of chars where \`have[c] == need[c]\`
- **Goals**
  - Minimize length (min window that covers)
  - Check existence / collect all windows with exact match
- **Representative Problems**
  - [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py) (minimize window)
  - [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py) (collect all exact matches)
  - [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py) (existence of exact match)
- **Key Variants**
  - **Variable-size + minimize**: [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
  - **Fixed-size window**: [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py), [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)

---

### 2.4 Cost-Bounded Window (\`sliding_window_cost_bounded\`)

- **Invariant**: Numeric cost (e.g., sum) obeys constraint, like \`sum >= target\` or \`sum <= target\`
- **State**: Single integer or small numeric state
- **Goal**: Often **minimize** length given constraint
- **Representative Problem**
  - [LeetCode 209 - Minimum Size Subarray Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)
- **Template**

\`\`\`python
left = 0
window_sum = 0
best = inf

for right, num in enumerate(nums):
    window_sum += num
    while window_sum >= target:
        best = min(best, right - left + 1)
        window_sum -= nums[left]
        left += 1
return 0 if best == inf else best
\`\`\`

---

### 2.5 Fixed-Size Window (\`sliding_window_fixed_size\`)

- **Invariant**: \`right - left + 1 == k\`
- **State**: Sum, frequency map, or other O(1) update state
- **Usage**
  - Moving average, max/min over fixed window, fixed-length anagram checks
- **Canonical Use in This Set**
  - [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
  - [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)

---

### 2.6 Sliding Window Comparison Table üìã

| Problem | Invariant | State | Window Size | Goal |
|--------|-----------|-------|-------------|------|
| [LeetCode 3 - Longest Substring Without Repeating Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py) | All unique | last index map | Variable | Maximize |
| [LeetCode 340 - Longest Substring with At Most K Distinct Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py) | ‚â§ K distinct | freq map | Variable | Maximize |
| [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py) | Cover all of t | need/have maps | Variable | Minimize |
| [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py) | Exact freq match | freq map | Fixed | Exists? |
| [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py) | Exact freq match | freq map | Fixed | All positions |
| [LeetCode 209 - Minimum Size Subarray Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py) | Sum ‚â• target | integer sum | Variable | Minimize |

---

### 2.7 When to Use Sliding Window ‚ùì

- **Use sliding window when**
  - Answer is a **contiguous subarray/substring**
  - You can maintain **window state incrementally** in O(1)
  - You need to **min/max** a property or check existence
- **Avoid sliding window when**
  - Subsequence is not contiguous ‚Üí think DP / combinatorics
  - State update is not local or O(1) ‚Üí prefix sums, segment tree, etc.

---

## üß† 3. API Kernel: \`TwoPointersTraversal\`

- **Definition**
  - Traverse sequence with two coordinated pointers under invariant-preserving rules
- **Sub-kernels in this graph**
  - \`TwoPointersTraversal\` (general)
  - \`FastSlowPointers\`
  - \`TwoPointerPartition\`
  - \`MergeSortedSequences\`
- **Typical Time/Space**
  - Time: \$O(n)\$ or \$O(n^2)\$ (for nested k-sum)
  - Space: \$O(1)\$ (index-based)

---

## üß© 4. Two Pointers Pattern Family

<!-- markmap: fold -->

### 4.1 Opposite Pointers (\`two_pointer_opposite\`) ‚ÜîÔ∏è

- **Pointers**
  - \`left = 0\`, \`right = n - 1\`
  - Move towards each other
- **Use Cases**
  - Sorted arrays: find pair sum / difference / condition
  - Symmetric checks: palindromes
  - Max/min function of two indices
- **Representative Problems (from mapping doc)**
  - (Note: not in local JSON, so link to LeetCode directly)
  - [LeetCode 11 - Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
  - [LeetCode 15 - 3Sum](https://leetcode.com/problems/3sum/)
  - [LeetCode 16 - 3Sum Closest](https://leetcode.com/problems/3sum-closest/)
  - [LeetCode 42 - Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)
  - [LeetCode 125 - Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
  - [LeetCode 167 - Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
  - [LeetCode 680 - Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)
- **In This Dataset**
  - [LeetCode 1 - Two Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py)
    - Classified under \`two_pointer_opposite\` pattern + hash map solution
    - As a pattern: ‚Äúpair with target‚Äù ‚Üí two pointers if sorted, hash map if not

---

### 4.2 Same-Direction / Writer Pattern (\`two_pointer_same_direction\` & writer variants) ‚úèÔ∏è

- **Pointers**
  - \`read\` scans input
  - \`write\` marks boundary of ‚Äúkept‚Äù elements
- **Invariant**
  - \`arr[0:write]\` is always valid, processed region
- **Use Cases**
  - In-place:
    - Remove elements
    - Deduplicate sorted array
    - Move zeroes, partition by condition
- **Representative Problems**
  - [LeetCode 26 - Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
  - [LeetCode 27 - Remove Element](https://leetcode.com/problems/remove-element/)
  - [LeetCode 80 - Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
  - [LeetCode 283 - Move Zeroes](https://leetcode.com/problems/move-zeroes/)
- **Key Pattern IDs**
  - \`two_pointer_writer_dedup\`
  - \`two_pointer_writer_remove\`
  - \`two_pointer_writer_compact\`

---

### 4.3 Fast‚ÄìSlow Pointers (\`FastSlowPointers\`) üê¢üêá

- **Pointers**
  - \`slow\` moves 1 step
  - \`fast\` moves 2 steps
- **Use Cases**
  - Cycle detection in linked list / implicit sequence
  - Find cycle start
  - Find middle of linked list
- **Pattern IDs**
  - \`fast_slow_cycle_detect\`
  - \`fast_slow_cycle_start\`
  - \`fast_slow_midpoint\`
  - \`fast_slow_implicit_cycle\`
- **Representative Problems**
  - [LeetCode 141 - Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
  - [LeetCode 142 - Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)
  - [LeetCode 202 - Happy Number](https://leetcode.com/problems/happy-number/)
  - [LeetCode 287 - Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)
  - [LeetCode 876 - Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)

---

### 4.4 Partition / Dutch Flag (\`TwoPointerPartition\`) üéå

- **Pointers**
  - Usually 3 indices: \`low\`, \`mid\`, \`high\`
- **Use Cases**
  - Partition array by:
    - Color (0/1/2)
    - < pivot / == pivot / > pivot
    - Even vs odd, positive vs negative
  - Foundation of quicksort & quickselect
- **Pattern IDs**
  - \`dutch_flag_partition\`
  - \`two_way_partition\`
  - \`quickselect_partition\`
- **Representative Problems**
  - [LeetCode 75 - Sort Colors](https://leetcode.com/problems/sort-colors/)
  - [LeetCode 215 - Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)
  - [LeetCode 905 - Sort Array By Parity](https://leetcode.com/problems/sort-array-by-parity/)
  - [LeetCode 922 - Sort Array By Parity II](https://leetcode.com/problems/sort-array-by-parity-ii/)

---

### 4.5 K-Sum / Multi-Sum (\`two_pointer_three_sum\`, \`two_pointer_k_sum\`) ‚ûï‚ûï‚ûï

- **Structure**
  - Sort array
  - Outer loop: fix first elements
  - Inner: opposite pointers to find remaining elements
- **Use Cases**
  - 2-sum, 3-sum, 4-sum, k-sum
- **Representative Problems**
  - [LeetCode 15 - 3Sum](https://leetcode.com/problems/3sum/)
  - [LeetCode 16 - 3Sum Closest](https://leetcode.com/problems/3sum-closest/)
  - [LeetCode 18 - 4Sum](https://leetcode.com/problems/4sum/)
  - [LeetCode 167 - Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)
- **Family**
  - \`two_sum_variants\`
  - \`multi_sum_enumeration\`

---

### 4.6 Merge Pattern (\`MergeSortedSequences\`) üîÄ

- **Pointers**
  - \`i\` over first sorted sequence
  - \`j\` over second sorted sequence
  - Optional \`k\` as write index
- **Use Cases**
  - Merge sorted arrays / lists
  - Compute median of two sorted arrays (conceptually)
  - Merge K sorted lists via pairwise merges
- **Pattern IDs**
  - \`merge_two_sorted_lists\`
  - \`merge_two_sorted_arrays\`
  - \`merge_sorted_from_ends\`
- **Representative Problems in Dataset**
  - [LeetCode 4 - Median of Two Sorted Arrays](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)
    - Uses both \`merge_two_sorted\` pattern and \`binary_search_on_answer\`
  - [LeetCode 23 - Merge k Sorted Lists](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)
    - \`merge_k_sorted_heap\` (min-heap)
    - \`merge_k_sorted_divide\` (divide-and-conquer)

---

### 4.7 Two Pointers Comparison Table üìã

| Pattern | Init | Movement | Termination | Time | Space | Use Case |
|--------|------|----------|-------------|------|-------|----------|
| Opposite | \`0, n-1\` | toward center | \`l >= r\` | O(n) | O(1) | Sorted pairs, palindromes |
| Same-Direction | \`0, 0\` | both forward | read end | O(n) | O(1) | In-place modification |
| Fast‚ÄìSlow | \`head, head\` | 1√ó vs 2√ó | meet or null | O(n) | O(1) | Cycle detection |
| Partition | \`0, 0, n-1\` | by value | \`mid > high\` | O(n) | O(1) | Dutch flag, quickselect |
| Dedup Enum | \`i, i+1, n-1\` | nested + opposite | all i done | O(n¬≤) | O(1) | 3Sum/4Sum |
| Merge | \`0, 0\` | advance smaller | both exhausted | O(m+n) | O(1) | Merge sorted sequences |

---

## üîó 5. Concrete Problems in This Dataset (with Patterns)

### 5.1 Sliding Window Core Set üåä

- [LeetCode 3 - Longest Substring Without Repeating Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
  - Pattern: \`sliding_window_unique\`
  - Kernel: \`SubstringSlidingWindow\`
  - Family: \`substring_window\`
- [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
  - Pattern: \`sliding_window_freq_cover\`
- [LeetCode 209 - Minimum Size Subarray Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)
  - Pattern: \`sliding_window_cost_bounded\`
- [LeetCode 340 - Longest Substring with At Most K Distinct Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
  - Pattern: \`sliding_window_at_most_k_distinct\`
- [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
  - Pattern: \`sliding_window_freq_cover\`
- [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
  - Pattern: \`sliding_window_freq_cover\`

---

### 5.2 Two Pointers / Merge / Binary Search Highlights ‚öôÔ∏è

- [LeetCode 1 - Two Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py)
  - Family: \`two_sum_variants\`
  - Algorithms: \`two_pointers\` (conceptual), plus hash map
- [LeetCode 4 - Median of Two Sorted Arrays](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)
  - Patterns: \`binary_search_on_answer\`, \`merge_two_sorted\`
  - Kernels: \`BinarySearchBoundary\`, \`KWayMerge\`
- [LeetCode 23 - Merge k Sorted Lists](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)
  - Patterns: \`merge_k_sorted_heap\`, \`merge_k_sorted_divide\`
- [LeetCode 25 - Reverse Nodes in k-Group](https://github.com/lufftw/neetcode/blob/main/solutions/0025_reverse_nodes_in_k_group.py)
  - Pattern: \`linked_list_k_group_reversal\`
  - Kernel: \`LinkedListInPlaceReversal\`
- [LeetCode 51 - N-Queens](https://github.com/lufftw/neetcode/blob/main/solutions/0051_n_queens.py)
  - Pattern: \`backtracking_n_queens\`
  - Kernel: \`BacktrackingExploration\`
- [LeetCode 2 - Add Two Numbers](https://github.com/lufftw/neetcode/blob/main/solutions/0002_add_two_numbers.py)
  - Family: \`linked_list_manipulation\`, \`math_number_theory\`
- [LeetCode 994 - Rotting Oranges](https://github.com/lufftw/neetcode/blob/main/solutions/0994_rotting_oranges.py)
  - Pattern: \`grid_bfs_propagation\`
  - Kernel: \`GridBFSMultiSource\`

---

## üß≠ 6. Learning Path Recommendations

### 6.1 Sliding Window Path (\`sliding_window_path\`) üìà

- [ ] [LeetCode 209 - Minimum Size Subarray Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py) ‚Äî numeric sum, minimize window
- [ ] [LeetCode 3 - Longest Substring Without Repeating Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py) ‚Äî unique chars, maximize window
- [ ] [LeetCode 340 - Longest Substring with At Most K Distinct Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py) ‚Äî K distinct
- [ ] [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py) ‚Äî fixed-size freq match
- [ ] [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py) ‚Äî collect all matches
- [ ] [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py) ‚Äî hardest, variable-size cover + minimize

---

### 6.2 Two Pointers Path (\`two_pointers_path\`) üö¶

- **Stage 1: Opposite & Same-Direction**
  - [ ] [LeetCode 1 - Two Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py) ‚Äî pair sum concept (hash + two pointers idea)
  - [ ] [LeetCode 167 - Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) ‚Äî pure opposite pointers
  - [ ] [LeetCode 283 - Move Zeroes](https://leetcode.com/problems/move-zeroes/) ‚Äî writer pattern
- **Stage 2: Partition & K-Sum**
  - [ ] [LeetCode 75 - Sort Colors](https://leetcode.com/problems/sort-colors/) ‚Äî Dutch flag
  - [ ] [LeetCode 15 - 3Sum](https://leetcode.com/problems/3sum/) ‚Äî dedup + opposite pointers
- **Stage 3: Merge & Advanced**
  - [ ] [LeetCode 4 - Median of Two Sorted Arrays](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py) ‚Äî merge vs binary search on partition
  - [ ] [LeetCode 23 - Merge k Sorted Lists](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py) ‚Äî K-way merge

---

## ‚úÖ 7. Quick Decision Cheat Sheet

- **Is answer a contiguous substring/subarray?**
  - Yes ‚Üí Can you maintain state in O(1) when moving L/R?
    - Yes ‚Üí **Sliding Window**
    - No ‚Üí Prefix sum / DP / other
- **Is array sorted or can be sorted?**
  - Yes ‚Üí Need pairs/tuples? ‚Üí **Opposite Pointers / K-Sum**
  - Yes ‚Üí Need in-place removal/dedup? ‚Üí **Writer Pattern**
  - Yes ‚Üí Need partitioning? ‚Üí **Dutch Flag / Quickselect**
- **Is structure a linked list or implicit sequence with potential cycle?**
  - Yes ‚Üí **Fast‚ÄìSlow Pointers**
- **Need to merge sorted sequences?**
  - Yes ‚Üí **Merge Pattern / K-Way Merge**

---

## üìå 8. Practice Checklist (Mark As You Go)

- Sliding Window Core
  - [ ] [LeetCode 3 - Longest Substring Without Repeating Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
  - [ ] [LeetCode 340 - Longest Substring with At Most K Distinct Characters](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
  - [ ] [LeetCode 76 - Minimum Window Substring](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
  - [ ] [LeetCode 567 - Permutation in String](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
  - [ ] [LeetCode 438 - Find All Anagrams in a String](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
  - [ ] [LeetCode 209 - Minimum Size Subarray Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)
- Two Pointers & Merge
  - [ ] [LeetCode 1 - Two Sum](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py)
  - [ ] [LeetCode 4 - Median of Two Sorted Arrays](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)
  - [ ] [LeetCode 23 - Merge k Sorted Lists](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)
  - [ ] [LeetCode 25 - Reverse Nodes in k-Group](https://github.com/lufftw/neetcode/blob/main/solutions/0025_reverse_nodes_in_k_group.py)
  - [ ] [LeetCode 51 - N-Queens](https://github.com/lufftw/neetcode/blob/main/solutions/0051_n_queens.py) (backtracking, but good contrast with sliding window)
  - [ ] [LeetCode 994 - Rotting Oranges](https://github.com/lufftw/neetcode/blob/main/solutions/0994_rotting_oranges.py) (BFS, contrast with sliding window on grids)`;
            const { root } = transformer.transform(markdown);
            const svg = d3.select('.markmap').append('svg');
            const mm = Markmap.create(svg.node(), { color: (node) => node.payload?.color || '#f59e0b' }, root);
            svg.node().mm = mm;
            if (window.markmap && window.markmap.Toolbar) {
                const toolbar = new window.markmap.Toolbar();
                toolbar.attach(mm);
                setTimeout(function() {
                    document.querySelectorAll('.mm-toolbar').forEach(function(toolbar) {
                        toolbar.querySelectorAll('.mm-toolbar-item').forEach(function(item) {
                            if ((item.title || '').toLowerCase().includes('dark')) item.remove();
                        });
                        var brand = toolbar.querySelector('.mm-toolbar-brand');
                        if (brand) {
                            brand.innerHTML = 'üü° NeetCode';
                            brand.href = '#'; brand.onclick = function(e) { e.preventDefault(); };
                            brand.style.fontSize = '12px'; brand.style.color = '#666';
                        }
                    });
                }, 200);
            }
        });
    </script>
</head>
<body>
    <div id="topbar">
        <button onclick="fitView()">Fit View</button>
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>
    <div class="markmap"></div>
</body>
</html>