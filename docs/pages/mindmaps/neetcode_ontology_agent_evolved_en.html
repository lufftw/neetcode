<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="description" content="Use this LeetCode knowledge graph mind map to learn core patterns and reusable API kernels, then route to the right technique for each problem.">
    
    <title>NeetCode Agent Evolved Mindmap - NeetCode Mind Maps</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        .markmap { width: 100%; height: 100%; }
        .markmap > svg { width: 100%; height: 100%; }
        #topbar {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            background: #fff; border-bottom: 1px solid #e5e7eb;
            padding: 8px 16px; display: flex; gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 13px;
        }
        #topbar button {
            padding: 4px 12px; border: 1px solid #d1d5db;
            border-radius: 4px; background: #fff; cursor: pointer;
        }
        #topbar button:hover { background: #f3f4f6; }
        .markmap { margin-top: 40px; height: calc(100% - 40px); }
    </style>
    <script>
        (function () {
            // Load script only once, return Promise that resolves when loaded
            function loadScriptOnce(src) {
                return new Promise((resolve, reject) => {
                    // Check if script already exists
                    if ([...document.scripts].some(s => s.src === src)) {
                        return resolve();
                    }

                    const s = document.createElement("script");
                    s.src = src;
                    s.defer = true;
                    s.onload = () => resolve();
                    s.onerror = () => reject(new Error("Failed to load: " + src));
                    document.head.appendChild(s);
                });
            }

            // Ensure all required markmap libraries are loaded
            async function ensureMarkmapLoaded() {
                // Ensure window.markmap exists
                if (!window.markmap) {
                    window.markmap = {};
                }

                // Load d3 first (required by markmap-view)
                if (!window.d3) {
                    await loadScriptOnce("https://cdn.jsdelivr.net/npm/d3@7");
                }
                // Load markmap-lib (provides Transformer)
                if (!window.markmap.Transformer) {
                    await loadScriptOnce("https://cdn.jsdelivr.net/npm/markmap-lib");
                }
                // Load markmap-view (provides Markmap)
                if (!window.markmap.Markmap) {
                    await loadScriptOnce("https://cdn.jsdelivr.net/npm/markmap-view");
                }
                // Load markmap-toolbar (provides Toolbar)
                if (!window.markmap.Toolbar) {
                    await loadScriptOnce("https://cdn.jsdelivr.net/npm/markmap-toolbar");
                }
            }

            // Initialize markmap visualization
            async function initMindmap() {
                const container = document.querySelector(".markmap");
                if (!container) return;

                try {
                    // Ensure libraries are loaded before initialization
                    await ensureMarkmapLoaded();

                    const mm = window.markmap;
                    if (!mm?.Transformer || !mm?.Markmap) {
                        console.warn("Markmap libraries not available");
                        return;
                    }

                    // Prevent duplicate rendering by removing existing SVG
                    container.querySelector("svg")?.remove();

                    // Initialize markmap
                    const { Transformer, Markmap } = mm;
                    const transformer = new Transformer();
                    const markdown = `---
title: LeetCode Knowledge Graph Mind Map (45 Problems) ‚Äî Kernels ‚Üí Patterns ‚Üí Problems
markmap:
  colorFreezeLevel: 2
  maxWidth: 300
---

# üéØ LeetCode Master Map: Kernels ‚Üí Patterns ‚Üí Problems
- **How to use**
  - Start from an **API Kernel** (reusable ‚Äúengine‚Äù), learn its **invariants**, then grind the mapped problems.
  - Track progress: do *1‚Äì2 problems per sub-pattern*, then mix across kernels.
  - **Glossary**
    - **Kernel** = reusable implementation template
    - **Pattern** = constraint/invariant specialization of a kernel
    - **Problem** = exercise instance that binds inputs/outputs to a pattern
  - **Quick router (decision guide)**
    - Need **contiguous subarray/substring** optimal under a constraint? ‚Üí \`SubstringSlidingWindow\` (fixed-size vs variable-size; counting vs sum)
    - Need **two ends / sorted scanning / in-place compaction**? ‚Üí **Family: Two-Pointer Techniques** ‚Üí \`TwoPointersTraversal\`
    - Need **cycle/midpoint** on linked structure or functional graph? ‚Üí **Family: Two-Pointer Techniques** ‚Üí \`FastSlowPointers\`
    - Need **reorder by predicate** or **Kth**? ‚Üí **Family: Two-Pointer Techniques** ‚Üí \`TwoPointerPartition\` (or \`HeapTopK\` for streaming)
    - Need **merge sorted sequences**? ‚Üí \`MergeSortedSequences\` / \`KWayMerge\`
    - Need **monotone predicate**? ‚Üí \`BinarySearchBoundary\` (index boundary vs answer space)
    - Need **shortest steps/time** on unweighted graph/grid? ‚Üí \`GridBFSMultiSource\`
- **Progress tracker**
  - [ ] Hash Map (complement lookup)
  - [ ] Family: Two-Pointer Techniques (Traversal + Fast/Slow + Partition)
  - [ ] Sliding Window (SubstringSlidingWindow)
  - [ ] Merge (Two-way + K-way)
  - [ ] Binary Search (Index boundary / Answer space)
  - [ ] Heap Top K / Kth
  - [ ] Monotonic Stack
  - [ ] Tree Traversal (DFS/BFS)
  - [ ] Dynamic Programming (1D/2D)
  - [ ] Grid Multi-Source BFS

<!-- markmap: fold -->
- **Pattern index (grouped)**
  - **Hash map**
    - \`hash_map_complement\` ‚Üí HashMapLookup
  - **Sliding window**
    - \`sliding_window_unique\` ‚Üí SubstringSlidingWindow
    - \`sliding_window_at_most_k_distinct\` ‚Üí SubstringSlidingWindow
    - \`sliding_window_freq_cover\` ‚Üí SubstringSlidingWindow
    - \`sliding_window_fixed_size\` ‚Üí SubstringSlidingWindow
    - \`sliding_window_cost_bounded\` ‚Üí SubstringSlidingWindow
  - **Two pointers (family)**
    - \`two_pointer_opposite_maximize\` ‚Üí TwoPointersTraversal
    - \`two_pointer_opposite_palindrome\` ‚Üí TwoPointersTraversal
    - \`two_pointer_three_sum\` ‚Üí TwoPointersTraversal
    - \`two_pointer_writer_dedup\` ‚Üí TwoPointersTraversal
    - \`two_pointer_writer_remove\` ‚Üí TwoPointersTraversal
    - \`two_pointer_writer_compact\` ‚Üí TwoPointersTraversal
    - \`fast_slow_cycle_detect\` ‚Üí FastSlowPointers
    - \`fast_slow_cycle_start\` ‚Üí FastSlowPointers
    - \`fast_slow_midpoint\` ‚Üí FastSlowPointers
    - \`fast_slow_implicit_cycle\` ‚Üí FastSlowPointers
    - \`dutch_flag_partition\` ‚Üí TwoPointerPartition
    - \`two_way_partition\` ‚Üí TwoPointerPartition
    - \`quickselect_partition\` ‚Üí TwoPointerPartition
  - **Merge**
    - \`merge_two_sorted_lists\` ‚Üí MergeSortedSequences
    - \`merge_two_sorted_arrays\` ‚Üí MergeSortedSequences
    - \`merge_sorted_from_ends\` ‚Üí MergeSortedSequences
    - \`merge_k_sorted_heap\` ‚Üí KWayMerge
    - \`merge_k_sorted_divide\` ‚Üí KWayMerge
  - **Binary search**
    - \`binary_search_index_boundary\` ‚Üí BinarySearchBoundary
    - \`binary_search_on_answer\` ‚Üí BinarySearchBoundary
    - \`binary_search_partition_index\` ‚Üí BinarySearchBoundary
  - **Heap**
    - \`heap_kth_element\` ‚Üí HeapTopK
  - **Linked list pointer surgery**
    - \`linked_list_k_group_reversal\` ‚Üí LinkedListInPlaceReversal
  - **Backtracking**
    - permutations / subsets / combinations / constraints / segmentation / grid paths ‚Üí BacktrackingExploration
  - **Graph BFS**
    - \`grid_bfs_propagation\` ‚Üí GridBFSMultiSource
  - **Monotonic stack**
    - \`next_greater_element\` ‚Üí MonotonicStack
    - \`histogram_max_rectangle\` ‚Üí MonotonicStack
  - **Trees**
    - \`tree_dfs_recursive\` ‚Üí TreeTraversalDFS
    - \`bfs_level_order\` ‚Üí TreeTraversalBFS
  - **DP**
    - \`dp_fibonacci_style\` ‚Üí DPSequence
    - \`dp_knapsack\` ‚Üí DPSequence
    - \`dp_longest_increasing\` ‚Üí DPSequence
    - \`dp_palindrome\` ‚Üí DPInterval

<!-- markmap: fold -->
- **Cross-kernel problems (same problem, multiple kernels)**
  - **[LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)(concept: merging order statistics) + \`BinarySearchBoundary\` (partition index)
  - **[LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)(streaming/top-k) + \`TwoPointerPartition\` (quickselect, batch)

---

## ‚ö° API Kernel: \`HashMapLookup\` (Complement / counting lookup)
- **Kernel Contract**
  - **Inputs**: array/string stream; order usually irrelevant; unsorted OK
  - **Outputs**: boolean / index pair / count
  - **Hooks**: \`key(x)\`, \`need(x)\`, \`on_hit(i, j)\`, \`update(map, x)\`
  - **Failure modes**: needs hashable key; worst-case hash collisions; ‚Äúreturn indices‚Äù depends on whether you mutate/sort
- **Core invariant**: at step \`i\`, map contains all information about elements in prefix \`nums[:i]\` needed to answer queries for \`nums[i]\`
- **Where you‚Äôll use this at work**
  - Deduplication, join-like lookups, frequency counting in logs/ETL
  - Fast membership tests for validation/anti-fraud rules
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when complement logic depends only on seen prefix (no need for future)
  - Doesn‚Äôt work when you must preserve original order under sorting-based transforms (unless you store indices)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 1](https://leetcode.com/problems/two-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py)
- **Patterns**
  - **Complement lookup** (\`hash_map_complement\`)
    - [LeetCode 1](https://leetcode.com/problems/two-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0001_two_sum.py)

<!-- markmap: fold -->
- **Template (complement)**
\`\`\`python
seen = {}  # value -> index (or count)
for i, x in enumerate(nums):
    y = target - x
    if y in seen:
        return [seen[y], i]  # hook: on_hit
    seen[x] = i             # hook: update
\`\`\`

---

## ‚ö° API Kernel: \`SubstringSlidingWindow\` (Window state machine)
- **Kernel Contract**
  - **Inputs**: string/array; typically 1D; often needs monotone validity when expanding \`R\`; fixed-size requires known window length
  - **Outputs**: max/min length, best window \`[L,R]\`, boolean existence, list of all windows
  - **Hooks**: \`add(x)\`, \`remove(x)\`, \`is_valid(state)\`, \`score(left, right, state)\`, \`update_answer(...)\`
  - **Failure modes**: if validity is non-monotone w.r.t expanding \`R\`, naive sliding window can fail or need extra DS (e.g., monotonic deque for max/min)
- **Core invariant**: maintain a window \`[L..R]\` that is *valid* under a rule; expand \`R\`, move \`L\` to restore validity
- **Complexity**: $O(n)$ time **when window validity is monotone w.r.t. expanding $R$** (so \`L\` only moves forward). If validity is non-monotone, sliding window may require auxiliary DS or fail.
- **Where you‚Äôll use this at work**
  - Log scanning / token streams (e.g., ‚Äúsmallest span covering keywords‚Äù)
  - Rate limiting and windowed metrics (fixed-size counts)
  - Sessionization / longest-recent-unique style analytics
- **Compositions**
  - Sliding window + **hash map / counter** (character counts, distinct tracking)
  - Sliding window (fixed-size) + **rolling hash** for fingerprints (follow-on)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
    - üî• [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
    - üî• [LeetCode 209](https://leetcode.com/problems/minimum-size-subarray-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
    - ‚≠ê [LeetCode 567](https://leetcode.com/problems/permutation-in-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
    - ‚≠ê [LeetCode 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
- **Patterns**
  - **Unique window** (\`sliding_window_unique\`) ‚Äî maximize
    - [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
  - **At most K distinct** (\`sliding_window_at_most_k_distinct\`) ‚Äî maximize
    - [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
  - **Frequency cover / exact match (variable-size)** (\`sliding_window_freq_cover\`) ‚Äî minimize/exists/all
    - [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
  - **Fixed-size window (exact multiset over length |t|)** (\`sliding_window_fixed_size\`) ‚Äî exists/all
    - [LeetCode 567](https://leetcode.com/problems/permutation-in-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
    - [LeetCode 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
  - **Cost bounded / sum constraint** (\`sliding_window_cost_bounded\`) ‚Äî minimize
    - [LeetCode 209](https://leetcode.com/problems/minimum-size-subarray-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)
    - **Note (correctness guardrail)**: this works because all numbers are **positive / non-negative** (sum changes monotonically as \`L\`/\`R\` move). With negatives, use prefix sums + monotone deque / other methods.

- **Comparison table (mental model)**
  - | Problem | Invariant | State | Window | Goal |
    |---|---|---|---|---|
    | [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
    | [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
    | [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)[c] ‚â• need[c]\` (equiv: \`formed == required\`) | need/have + formed | variable | min |
    | [LeetCode 567](https://leetcode.com/problems/permutation-in-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
    | [LeetCode 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
    | [LeetCode 209](https://leetcode.com/problems/minimum-size-subarray-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)(nums non-negative) | integer sum | variable | min |

<!-- markmap: fold -->
- **Template (explicit hooks + invariants)**
\`\`\`python
left = 0
state = init_state()
ans = init_ans()

for right, x in enumerate(seq):
    add(state, x)  # hook

    # Mode A: maximize / maintain validity by shrinking while invalid
    while not is_valid(state):  # hook
        remove(state, seq[left])  # hook
        left += 1

    # Invariants at this point:
    # 1) Before ans update, window [left..right] is valid: is_valid(state) == True
    # 2) state == aggregate(seq[left:right+1]) (freq/sum/etc.)

    ans = update_answer(ans, left, right, state)  # hook

    # Mode B (alternative): minimize a valid window by shrinking while still valid
    # while is_valid(state):
    #     ans = update_answer(ans, left, right, state)
    #     remove(state, seq[left]); left += 1

# Fixed-size window note:
# - When window size is fixed (k), you "add right", and if right-left+1 > k then "remove left" once.
\`\`\`

<!-- markmap: fold -->
- **Trade-offs (common interviewer follow-ups)**
  - **[LeetCode 76](https://leetcode.com/problems/minimum-window-substring/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)**: array counter (e.g., size 128/256) is faster/simpler for ASCII; hashmap is more general for Unicode/large alphabets
  - Tracking \`formed/required\` avoids $O(\\Sigma)$ checks per step; naive ‚Äúcovers‚Äù checks often TLE or bug on duplicates

---

## üß© Family: Two-Pointer Techniques
- **Traversal** (\`TwoPointersTraversal\`): monotone movement to reduce search space (often sorted/two-ends)
- **Fast/Slow** (\`FastSlowPointers\`): rate mismatch for cycles/midpoints in linked/functional graphs
- **Partition** (\`TwoPointerPartition\`): region invariants for rearrangement/selection

---

## ‚ö° API Kernel: \`TwoPointersTraversal\` (Coordinated pointer movement)
- **Kernel Contract**
  - **Inputs**: array/string; often sorted or supports monotone scan; may require in-place writes
  - **Outputs**: max score, boolean, indices, modified array length
  - **Hooks**: \`should_move_left(...)\`, \`should_move_right(...)\`, \`keep(x)\`, \`write(x)\`, \`skip_duplicates(...)\`
  - **Failure modes**: opposite-pointers usually needs sorted/monotone objective; writer assumes in-place mutation allowed
- **Core invariants (by subtype)**
  - **Opposite pointers**: maintain a feasible search interval \`[L,R]\`; each move preserves existence of an optimal solution within the updated interval (dominance argument)
  - **Writer (reader/write)**: elements in \`arr[:write]\` are exactly the kept/compacted elements from \`arr[:read]\` and satisfy the filter/dedup constraint
- **Where you‚Äôll use this at work**
  - In-place filtering/compaction in performance-sensitive ETL/buffers
  - Two-end scans over sorted data (dedup, pair checks, resource packing variants)
- **Compositions**
  - Two pointers + **sorting** (k-sum family, dedup enumeration)
  - Two pointers + **hash map** (when one pointer moves and you need fast membership)
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when pointer moves are monotone and you have a dominance/feasibility argument
  - Doesn‚Äôt work when objective/constraints are non-monotone on pointer moves (often indicates need for DP/graph/search)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 11](https://leetcode.com/problems/container-with-most-water/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0011_container_with_most_water.py)
    - üî• [LeetCode 15](https://leetcode.com/problems/3sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0015_3sum.py)
    - üî• [LeetCode 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0026_remove_duplicates_from_sorted_array.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 27](https://leetcode.com/problems/remove-element/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0027_remove_element.py)
    - ‚≠ê [LeetCode 283](https://leetcode.com/problems/move-zeroes/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0283_move_zeroes.py)
    - ‚≠ê [LeetCode 125](https://leetcode.com/problems/valid-palindrome/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0125_valid_palindrome.py)
    - ‚≠ê [LeetCode 680](https://leetcode.com/problems/valid-palindrome-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0680_valid_palindrome_ii.py)
    - ‚≠ê [LeetCode 16](https://leetcode.com/problems/3sum-closest/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0016_3sum_closest.py)
- **Patterns**
  - **Opposite pointers: maximize function** (\`two_pointer_opposite_maximize\`)
    - [LeetCode 11](https://leetcode.com/problems/container-with-most-water/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0011_container_with_most_water.py)
    - **Lemma (dominance)**: If \`height[L] ‚â§ height[R]\`, any container using \`L\` with some \`R' < R\` cannot beat current width while min-height is bounded by \`height[L]\`; therefore incrementing \`L\` cannot discard the optimal.
  - **Opposite pointers: palindrome validation** (\`two_pointer_opposite_palindrome\`)
    - [LeetCode 125](https://leetcode.com/problems/valid-palindrome/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0125_valid_palindrome.py)
    - [LeetCode 680](https://leetcode.com/problems/valid-palindrome-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0680_valid_palindrome_ii.py)
  - **Dedup enumeration (sorted + skip): 3Sum** (\`two_pointer_three_sum\`)
    - [LeetCode 15](https://leetcode.com/problems/3sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0015_3sum.py)
    - [LeetCode 16](https://leetcode.com/problems/3sum-closest/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0016_3sum_closest.py)
  - **Writer patterns (in-place)**  
    - Deduplicate (\`two_pointer_writer_dedup\`)
      - [LeetCode 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0026_remove_duplicates_from_sorted_array.py)
      - [LeetCode 80](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0080_remove_duplicates_from_sorted_array_ii.py)
    - Remove (\`two_pointer_writer_remove\`)
      - [LeetCode 27](https://leetcode.com/problems/remove-element/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0027_remove_element.py)
    - Compact (\`two_pointer_writer_compact\`)
      - [LeetCode 283](https://leetcode.com/problems/move-zeroes/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0283_move_zeroes.py)

- **Key table (choose the right sub-pattern)**
  - | Sub-pattern | When it applies | Typical invariant | Example |
    |---|---|---|---|
    | Opposite pointers | sorted / symmetric / 2-end optimization | optimal remains in \`[L,R]\` | [LeetCode 11](https://leetcode.com/problems/container-with-most-water/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0011_container_with_most_water.py)
    | Writer | in-place filter/dedup | \`arr[:write]\` is exactly ‚Äúkept from arr[:read]‚Äù | [LeetCode 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0026_remove_duplicates_from_sorted_array.py)
    | Dedup enum | k-sum family (sort + skip) | skip duplicates at same role | [LeetCode 15](https://leetcode.com/problems/3sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0015_3sum.py)

<!-- markmap: fold -->
- **Templates**
  - **Opposite pointers (dominance-driven)**
\`\`\`python
L, R = 0, len(arr) - 1
best = init_best()

while L < R:
    best = update(best, L, R)  # hook: score(L,R)
    if should_move_left(arr, L, R):  # hook (often based on dominance)
        L += 1
    else:
        R -= 1
return best
\`\`\`
  - **Writer (reader/write)**
\`\`\`python
write = 0
for read in range(len(arr)):
    if keep(arr[read]):              # hook
        arr[write] = arr[read]       # hook: write
        write += 1
return write  # new length
\`\`\`

---

## ‚ö° API Kernel: \`FastSlowPointers\` (Floyd / midpoint / implicit cycles)
- **Kernel Contract**
  - **Inputs**: linked list node / functional graph \`f(x)\` / array-as-next-pointer
  - **Outputs**: boolean cycle, cycle start node/index, midpoint node
  - **Hooks**: \`next(node)\` / \`f(x)\`, \`meet_action\`, \`phase2_reset\`
  - **Failure modes**: requires deterministic ‚Äúnext‚Äù; can‚Äôt detect cycles if graph branches (need visited set)
- **Core invariant**: fast moves 2√ó, slow moves 1√ó; if a cycle exists they meet
- **Where you‚Äôll use this at work**
  - Detecting loops in pointer-like structures, iterators, state machines
  - Finding midpoint for splitting lists (e.g., mergesort on linked list)
- **Compositions**
  - Fast/slow + **hash set** (when you need explicit visited for general graphs)
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when each state has exactly one successor (linked list / functional graph)
  - Doesn‚Äôt work when nodes have multiple outgoing edges (use DFS/BFS + visited)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 141](https://leetcode.com/problems/linked-list-cycle/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0141_linked_list_cycle.py)
    - üî• [LeetCode 142](https://leetcode.com/problems/linked-list-cycle-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0142_linked_list_cycle_ii.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 876](https://leetcode.com/problems/middle-of-the-linked-list/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0876_middle_of_the_linked_list.py)
    - ‚≠ê [LeetCode 202](https://leetcode.com/problems/happy-number/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0202_happy_number.py)
- **Patterns**
  - Cycle detect (\`fast_slow_cycle_detect\`)
    - [LeetCode 141](https://leetcode.com/problems/linked-list-cycle/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0141_linked_list_cycle.py)
  - Cycle start (\`fast_slow_cycle_start\`)
    - [LeetCode 142](https://leetcode.com/problems/linked-list-cycle-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0142_linked_list_cycle_ii.py)
  - Midpoint (\`fast_slow_midpoint\`)
    - [LeetCode 876](https://leetcode.com/problems/middle-of-the-linked-list/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0876_middle_of_the_linked_list.py)
  - Implicit cycle (\`fast_slow_implicit_cycle\`)
    - [LeetCode 202](https://leetcode.com/problems/happy-number/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0202_happy_number.py)

<!-- markmap: fold -->
- **Template (Floyd cycle detect + start)**
\`\`\`python
slow = fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        break
else:
    return None  # no cycle (hook: return False for detect)

# phase 2: find start
p1, p2 = head, slow
while p1 != p2:
    p1 = p1.next
    p2 = p2.next
return p1
\`\`\`

---

## ‚ö° API Kernel: \`TwoPointerPartition\` (Partitioning / selection)
- **Kernel Contract**
  - **Inputs**: array; in-place mutation allowed; predicate or pivot selection
  - **Outputs**: partitioned array; pivot final index; selection result (kth)
  - **Hooks**: \`predicate(x)\`, \`choose_pivot(l,r)\`, \`swap(i,j)\`
  - **Failure modes**: quickselect worst-case $O(n^2)$ with bad pivots; mutates array (may violate ‚Äúdon‚Äôt modify input‚Äù)
- **Core invariant**: maintain regions (e.g., \`< pivot\`, \`= pivot\`, \`> pivot\`)
- **Where you‚Äôll use this at work**
  - In-place bucketing/segregation by predicate (e.g., feature flags, routing)
  - Selection/ranking on batch data without full sort
- **Compositions**
  - Partition + heap (\`HeapTopK\`) for Kth/top-k trade-offs (batch vs streaming)
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when in-place mutation is acceptable and you need selection/partition
  - Doesn‚Äôt work when you need stability (relative order preserved) unless you use stable partition (extra space)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 75](https://leetcode.com/problems/sort-colors/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0075_sort_colors.py)
    - üî• [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 905](https://leetcode.com/problems/sort-array-by-parity/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0905_sort_array_by_parity.py)
    - ‚≠ê [LeetCode 922](https://leetcode.com/problems/sort-array-by-parity-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0922_sort_array_by_parity_ii.py)
- **Patterns**
  - Dutch flag (\`dutch_flag_partition\`)
    - [LeetCode 75](https://leetcode.com/problems/sort-colors/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0075_sort_colors.py)
  - Two-way partition (\`two_way_partition\`)
    - [LeetCode 905](https://leetcode.com/problems/sort-array-by-parity/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0905_sort_array_by_parity.py)
    - [LeetCode 922](https://leetcode.com/problems/sort-array-by-parity-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0922_sort_array_by_parity_ii.py)
  - Quickselect partition (\`quickselect_partition\`)
    - [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)
    - **Note**: expected $O(n)$, worst-case $O(n^2)$ unless using median-of-medians; space $O(1)$ iterative / $O(\\log n)$ recursion.

<!-- markmap: fold -->
- **Template (quickselect, iterative)**
\`\`\`python
def partition(l, r):
    pivot = nums[r]  # hook: choose_pivot
    i = l
    for j in range(l, r):
        if nums[j] <= pivot:          # hook: comparator for kth largest/smallest
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
    nums[i], nums[r] = nums[r], nums[i]
    return i

l, r = 0, len(nums) - 1
while True:
    p = partition(l, r)
    if p == k_index:
        return nums[p]
    elif p < k_index:
        l = p + 1
    else:
        r = p - 1
\`\`\`

---

## ‚ö° API Kernel: \`MergeSortedSequences\` (Two-way merge)
- **Kernel Contract**
  - **Inputs**: two sorted sequences (arrays/lists/linked lists); sometimes in-place target buffer
  - **Outputs**: merged sorted sequence
  - **Hooks**: \`less(a,b)\`, \`take_left()\`, \`take_right()\`
  - **Failure modes**: requires sorted inputs; in-place merges need sufficient buffer / careful indexing
- **Core invariant**: pointers \`i,j\` always point to next unmerged element in each sorted sequence
- **Where you‚Äôll use this at work**
  - Merging sorted runs (external sort), merging time-ordered event streams
  - Two-way ‚Äústream join‚Äù style logic when inputs are ordered
- **Compositions**
  - MergeSortedSequences + KWayMerge (k-way built from repeated two-way merges)
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when inputs are sorted and you want linear-time merge
  - Doesn‚Äôt work when inputs are unsorted (sort first or use heap)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 21](https://leetcode.com/problems/merge-two-sorted-lists/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0021_merge_two_sorted_lists.py)
    - üî• [LeetCode 88](https://leetcode.com/problems/merge-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0088_merge_sorted_array.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 977](https://leetcode.com/problems/squares-of-a-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0977_squares_of_a_sorted_array.py)
- **Patterns**
  - Merge two sorted lists (\`merge_two_sorted_lists\`)
    - [LeetCode 21](https://leetcode.com/problems/merge-two-sorted-lists/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0021_merge_two_sorted_lists.py)
  - Merge two sorted arrays (\`merge_two_sorted_arrays\`)
    - [LeetCode 88](https://leetcode.com/problems/merge-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0088_merge_sorted_array.py)
  - Merge from ends (\`merge_sorted_from_ends\`)
    - [LeetCode 977](https://leetcode.com/problems/squares-of-a-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0977_squares_of_a_sorted_array.py)

<!-- markmap: fold -->
- **Template (two-way merge)**
\`\`\`python
i = j = 0
out = []
while i < len(A) and j < len(B):
    if A[i] <= B[j]:
        out.append(A[i]); i += 1
    else:
        out.append(B[j]); j += 1
out.extend(A[i:])
out.extend(B[j:])
return out
\`\`\`

---

## ‚ö° API Kernel: \`KWayMerge\` (K sorted sequences)
- **Kernel Contract**
  - **Inputs**: K sorted lists/iterators; may be streaming
  - **Outputs**: merged sorted list/iterator
  - **Hooks**: \`push(item)\`, \`pop_min()\`, \`advance(source)\`
  - **Failure modes**: requires sorted sources; heap approach needs memory for heap nodes
- **Two production-grade strategies**
  - **Min-heap** (\`merge_k_sorted_heap\`) ‚Äî $O(N \\log K)$, great when K is large and lists are uneven / streaming
  - **Divide & conquer** (\`merge_k_sorted_divide\`) ‚Äî $O(N \\log K)$, often faster constants + less heap churn
- **Where you‚Äôll use this at work**
  - Merging sorted run files (external merge), log compaction
  - Streaming k-way merge of time-ordered events
- **Compositions**
  - KWayMerge + Binary search partitioning for order statistics across sorted arrays (see [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py))
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)(hybrid; see BinarySearchBoundary partition)
- **Problems**
  - [LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)
  - Cross-kernel hybrid (merge + binary search on partition)
    - [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)

<!-- markmap: fold -->
- **Trade-offs (heap vs divide & conquer)**
  - **[LeetCode 23](https://leetcode.com/problems/merge-k-sorted-lists/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0023_merge_k_sorted_lists.py)**:
    - Heap: best for uneven lists or when you can stream nodes incrementally; cost is heap churn
    - Divide & conquer: often faster constants; merges are cache-friendly; simpler correctness once merge-two is solid

---

## ‚ö° API Kernel: \`BinarySearchBoundary\` (Boundary + answer space)
- **Kernel Contract**
  - **Inputs**: sorted array for index boundary; numeric answer space for feasibility search; monotone predicate required
  - **Outputs**: index (lower/upper bound), min/max feasible value, or partition index
  - **Hooks**: \`pred(mid)\` (monotone), \`lo/hi\` initialization, \`mid\` bias (lower/upper), boundary return convention
  - **Failure modes**: non-monotone predicate; off-by-one from inconsistent loop invariants
- **Core invariant**: predicate is monotone; binary search maintains an interval that still contains the boundary/answer
- **Where you‚Äôll use this at work**
  - lower_bound/upper_bound lookups in sorted data
  - capacity planning style ‚Äúmin feasible X‚Äù (throughput, resource sizing)
- **Compositions**
  - Binary search on answer + greedy/DP feasibility checker
  - Partition-index binary search in sorted arrays (order statistics)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)(partition index)
- **Patterns**
  - **Binary search on index boundary** (\`binary_search_index_boundary\`)
    - (canonical) first \`>= x\`, last \`<= x\`, lower_bound/upper_bound
  - **Binary search on answer space** (\`binary_search_on_answer\`)
    - (canonical) min feasible / max feasible under monotone feasibility predicate
  - **Binary search on partition (index) in sorted arrays** (\`binary_search_partition_index\`)
    - [LeetCode 4](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0004_median_of_two_sorted_arrays.py)
    - **Invariant**: choose partition \`i\` in A (and \`j\` in B) so left parts have size \`k\`; maintain \`A[i-1] ‚â§ B[j]\` and \`B[j-1] ‚â§ A[i]\` as feasibility; predicate is monotone in \`i\`.

<!-- markmap: fold -->
- **Templates**
  - **Index boundary (lower_bound: first index with pred True)**
\`\`\`python
lo, hi = 0, len(arr)  # hi is exclusive
while lo < hi:
    mid = (lo + hi) // 2
    if pred(arr[mid]):      # monotone: False...False True...True
        hi = mid
    else:
        lo = mid + 1
return lo
\`\`\`
  - **Answer space (min feasible)**
\`\`\`python
lo, hi = low_possible, high_possible  # inclusive bounds
while lo < hi:
    mid = (lo + hi) // 2
    if feasible(mid):  # monotone: True for >= answer (or <=, depending)
        hi = mid
    else:
        lo = mid + 1
return lo
\`\`\`

---

## ‚ö° API Kernel: \`HeapTopK\` (Top-K / Kth / streaming)
- **Kernel Contract**
  - **Inputs**: stream or batch array; comparator for ‚Äúbest‚Äù; K
  - **Outputs**: kth element, list of top K, running median (two-heaps variant)
  - **Hooks**: \`push(x)\`, \`pop()\`, \`should_evict(heap, x)\`, \`compare(a,b)\`
  - **Failure modes**: memory $O(k)$; not ideal if you need stable ordering without extra bookkeeping
- **Core invariant**: heap maintains the current best candidates (size K or two-heaps for median)
- **Where you‚Äôll use this at work**
  - Trending topics / top-K queries over streams
  - Online aggregation; ranking dashboards
  - Follow-on: approximate heavy hitters (e.g., Count-Min Sketch)
- **Compositions**
  - HeapTopK + TwoPointerPartition (choose heap for streaming; quickselect for batch)
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when you need incremental maintenance or only top-K (not full sort)
  - Doesn‚Äôt work when you need total order of all items (sort) or worst-case linear-time guarantees (quickselect caveats)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)
- **Patterns**
  - Kth element (\`heap_kth_element\`)
    - [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)
    - **Note**: $O(n \\log k)$ using size-$k$ min-heap; or $O(n + k \\log n)$ if heapify then pop k times.

<!-- markmap: fold -->
- **Trade-offs ([LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py))**
  - Heap: $O(n \\log k)$, great for streaming / you only keep K items; predictable
  - Quickselect: average $O(n)$, but worst-case $O(n^2)$; mutates array; great for batch when mutation is OK

---

## ‚ö° API Kernel: \`LinkedListInPlaceReversal\` (Pointer surgery)
- **Kernel Contract**
  - **Inputs**: linked list head; group size \`k\` or boundaries
  - **Outputs**: new head; modified list
  - **Hooks**: \`reverse_segment(start, end)\`, \`connect(prev, new_head, new_tail, next)\`
  - **Failure modes**: off-by-one at boundaries; losing pointers when not saving \`next\`
- **Core invariant**: maintain \`prev/curr/next\` and reconnect boundaries correctly
- **Where you‚Äôll use this at work**
  - In-place list/buffer transformations where allocation is restricted
  - Reversing chunks (batch processing) and pointer manipulation exercises
- **Compositions**
  - FastSlowPointers (midpoint) + reversal (palindrome list variants, not listed here)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 25](https://leetcode.com/problems/reverse-nodes-in-k-group/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0025_reverse_nodes_in_k_group.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 2](https://leetcode.com/problems/add-two-numbers/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0002_add_two_numbers.py)(related family, different operation)
- **Patterns**
  - Reverse in k-group (\`linked_list_k_group_reversal\`)
    - [LeetCode 25](https://leetcode.com/problems/reverse-nodes-in-k-group/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0025_reverse_nodes_in_k_group.py)
- **Related (same family, different operation)**
  - Arithmetic on lists
    - [LeetCode 2](https://leetcode.com/problems/add-two-numbers/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0002_add_two_numbers.py)

<!-- markmap: fold -->
- **Template (reverse k-group skeleton)**
\`\`\`python
dummy = ListNode(0, head)
group_prev = dummy

while True:
    kth = get_kth(group_prev, k)   # hook
    if not kth:
        break
    group_next = kth.next

    # reverse [group_prev.next .. kth]
    prev, curr = group_next, group_prev.next
    while curr != group_next:
        nxt = curr.next
        curr.next = prev
        prev = curr
        curr = nxt

    tmp = group_prev.next          # new tail after reverse
    group_prev.next = kth          # connect new head
    group_prev = tmp               # advance
return dummy.next
\`\`\`

---

## ‚ö° API Kernel: \`BacktrackingExploration\` (Choose ‚Üí Explore ‚Üí Unchoose)
- **Kernel Contract**
  - **Inputs**: candidate set/sequence/grid; constraints; optional sorting for dedup
  - **Outputs**: list of solutions, count, boolean existence
  - **Hooks**: \`choices(state)\`, \`apply(choice)\`, \`undo(choice)\`, \`is_solution(state)\`, \`should_prune(state)\`
  - **Failure modes**: exponential blowup without pruning; dedup bugs without consistent ordering
- ==Core invariant==: **state exactly matches the current path** (no ‚Äúghost marks‚Äù after backtrack)
- **Complexity**: usually exponential / factorial; aim for pruning + dedup
- **Where you‚Äôll use this at work**
  - Configuration search, constraint solving, generating test cases / combinations
  - Small-state exploration with pruning rules (feature combinations, schedules)
- **Compositions**
  - Backtracking + sorting + dedup (same-level skip / used[])
  - Backtracking + preprocessing (hash sets, constraint bitmasks) for faster \`should_prune\`
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 39](https://leetcode.com/problems/combination-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0039_combination_sum.py)
    - üî• [LeetCode 51](https://leetcode.com/problems/n-queens/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0051_n_queens.py)
    - üî• [LeetCode 78](https://leetcode.com/problems/subsets/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0078_subsets.py)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 46](https://leetcode.com/problems/permutations/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0046_permutations.py)
    - ‚≠ê [LeetCode 47](https://leetcode.com/problems/permutations-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0047_permutations_ii.py)
    - ‚≠ê [LeetCode 90](https://leetcode.com/problems/subsets-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0090_subsets_ii.py)
    - ‚≠ê [LeetCode 40](https://leetcode.com/problems/combination-sum-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0040_combination_sum_ii.py)
    - ‚≠ê [LeetCode 131](https://leetcode.com/problems/palindrome-partitioning/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0131_palindrome_partitioning.py)
    - ‚≠ê [LeetCode 79](https://leetcode.com/problems/word-search/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0079_word_search.py)
- **Sub-patterns ‚Üí problems**
  - **Permutations**
    - [LeetCode 46](https://leetcode.com/problems/permutations/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0046_permutations.py)
    - [LeetCode 47](https://leetcode.com/problems/permutations-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0047_permutations_ii.py)(sort + same-level skip)*
  - **Subsets**
    - [LeetCode 78](https://leetcode.com/problems/subsets/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0078_subsets.py)
    - [LeetCode 90](https://leetcode.com/problems/subsets-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0090_subsets_ii.py)(sort + same-level skip)*
  - **Combinations / target search**
    - [LeetCode 77](https://leetcode.com/problems/combinations/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0077_combinations.py)
    - [LeetCode 39](https://leetcode.com/problems/combination-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0039_combination_sum.py)(reuse allowed)*
    - [LeetCode 40](https://leetcode.com/problems/combination-sum-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0040_combination_sum_ii.py)(no reuse + dedup)*
    - [LeetCode 216](https://leetcode.com/problems/combination-sum-iii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0216_combination_sum_iii.py)(fixed count + fixed sum)*
  - **Constraint satisfaction**
    - [LeetCode 51](https://leetcode.com/problems/n-queens/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0051_n_queens.py)
    - [LeetCode 52](https://leetcode.com/problems/n-queens-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0052_n_queens_ii.py)
  - **String segmentation**
    - [LeetCode 93](https://leetcode.com/problems/restore-ip-addresses/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0093_restore_ip_addresses.py)
    - [LeetCode 131](https://leetcode.com/problems/palindrome-partitioning/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0131_palindrome_partitioning.py)
  - **Grid path search**
    - [LeetCode 79](https://leetcode.com/problems/word-search/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0079_word_search.py)

<!-- markmap: fold -->
- **Template (choose ‚Üí explore ‚Üí unchoose)**
\`\`\`python
def dfs(state):
    if is_solution(state):            # hook
        record(state)
        return
    for choice in choices(state):     # hook
        if should_prune(state, choice):  # hook
            continue
        apply(state, choice)          # hook
        dfs(state)
        undo(state, choice)           # hook
\`\`\`

<!-- markmap: fold -->
- **Dedup cheat sheet**
  - Sort + same-level skip (subsets/combos):
\`\`\`python
if i > start and nums[i] == nums[i-1]:
    continue
\`\`\`
  - Sort + used[] constraint (permutations):
\`\`\`python
if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
    continue
\`\`\`

---

## ‚ö° API Kernel: \`GridBFSMultiSource\` (Wavefront BFS)
- **Kernel Contract**
  - **Inputs**: grid/graph; set of sources; unweighted edges (unit cost)
  - **Outputs**: min time/steps, distance grid, reachability
  - **Hooks**: \`neighbors(cell)\`, \`is_valid(cell)\`, \`is_source(cell)\`, \`mark_visited(cell)\`, \`distance[cell]\`
  - **Failure modes**: if edges have weights ‚â† 1, need Dijkstra; revisiting without visited/dist checks breaks correctness
- **Core invariant**: **When a cell is dequeued, its assigned distance/time is minimal (first time reached), because the queue processes nondecreasing distance layers; all enqueued neighbors get distance = current+1 if unvisited.**
- **Where you‚Äôll use this at work**
  - Spread/propagation simulations (contagion, cache warmup wave)
  - Nearest facility / shortest-time-to-signal on grids/maps
  - SLA reachability regions in discrete maps
- **Compositions**
  - BFS + multi-source initialization: seed queue with all sources at distance 0
- **Works when‚Ä¶ / Doesn‚Äôt work when‚Ä¶**
  - Works when transitions are unweighted (each step costs 1)
  - Doesn‚Äôt work for weighted edges (use priority queue / Dijkstra)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 994](https://leetcode.com/problems/rotting-oranges/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0994_rotting_oranges.py)
- **Pattern**
  - Grid propagation (\`grid_bfs_propagation\`)
    - [LeetCode 994](https://leetcode.com/problems/rotting-oranges/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0994_rotting_oranges.py)

<!-- markmap: fold -->
- **Template (multi-source BFS)**
\`\`\`python
from collections import deque

q = deque()
dist = [[-1]*C for _ in range(R)]

for r in range(R):
    for c in range(C):
        if is_source(r, c):           # hook
            q.append((r, c))
            dist[r][c] = 0

while q:
    r, c = q.popleft()
    for nr, nc in neighbors(r, c):    # hook
        if dist[nr][nc] != -1:
            continue
        if not is_valid(nr, nc):      # hook
            continue
        dist[nr][nc] = dist[r][c] + 1
        q.append((nr, nc))
\`\`\`

---

## ‚ö° API Kernel: \`MonotonicStack\` (Next greater/smaller + range dominance)
- **Kernel Contract**
  - **Inputs**: array/time series; comparison direction (increasing/decreasing)
  - **Outputs**: next greater/smaller indices/values; max area via previous/next smaller boundaries
  - **Hooks**: \`while stack and violates_monotone(...)\`, \`pop_action(popped)\`, \`push(i)\`
  - **Failure modes**: wrong inequality (\`<\` vs \`<=\`) breaks duplicates handling; forgetting sentinel causes missed flush
- **Core invariant**: stack indices maintain a monotone property (increasing/decreasing values), enabling amortized $O(n)$ pops
- **Where you‚Äôll use this at work**
  - Time-series ‚Äúnext time higher/lower‚Äù queries, alerting, span computations
  - Range dominance boundaries for histogram-like analytics
- **Compositions**
  - Monotonic stack + sliding window (follow-on: monotonic deque for window max/min)
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 739](https://leetcode.com/problems/daily-temperatures/description/)
    - üî• [LeetCode 84](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)
  - **High-frequency (‚≠ê)**
    - ‚≠ê [LeetCode 496](https://leetcode.com/problems/next-greater-element-i/description/)
- **Patterns ‚Üí problems**
  - Next greater element (\`next_greater_element\`)
    - [LeetCode 739](https://leetcode.com/problems/daily-temperatures/description/)
    - [LeetCode 496](https://leetcode.com/problems/next-greater-element-i/description/)
  - Histogram max rectangle (\`histogram_max_rectangle\`)
    - [LeetCode 84](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)

---

## ‚ö° API Kernel: \`TreeTraversalDFS\` (Recursive / iterative DFS on trees)
- **Kernel Contract**
  - **Inputs**: binary tree node (or N-ary); recursion/stack allowed
  - **Outputs**: aggregate value, boolean, path, LCA node
  - **Hooks**: \`visit(node)\`, \`combine(left, right)\`, \`base_case(None)\`
  - **Failure modes**: stack overflow in deep trees (iterative); mixing preorder/inorder/postorder semantics
- **Core invariant**: each call returns correct result for its subtree; combine step is the only place parent depends on children
- **Where you‚Äôll use this at work**
  - Hierarchical aggregation, validation, search in tree-like data models
- **Compositions**
  - DFS + hash map (track parent pointers / depths) for LCA variants
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)
    - üî• [LeetCode 98](https://leetcode.com/problems/validate-binary-search-tree/description/)
    - üî• [LeetCode 236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)
- **Patterns ‚Üí problems**
  - Recursive DFS (\`tree_dfs_recursive\`)
    - [LeetCode 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)
    - [LeetCode 98](https://leetcode.com/problems/validate-binary-search-tree/description/)
    - [LeetCode 236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

---

## ‚ö° API Kernel: \`TreeTraversalBFS\` (Level-order traversal)
- **Kernel Contract**
  - **Inputs**: tree root; queue
  - **Outputs**: list of levels, min depth, right-side view variants
  - **Hooks**: \`enqueue(children)\`, \`process_level(level_nodes)\`
  - **Failure modes**: mixing levels without queue-size snapshot
- **Core invariant**: queue holds exactly the next frontier; processing one ‚Äúlevel batch‚Äù corresponds to a fixed depth
- **Where you‚Äôll use this at work**
  - Breadth-first processing of hierarchical tasks; level-based batching
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 102](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)
- **Patterns ‚Üí problems**
  - Level order (\`bfs_level_order\`)
    - [LeetCode 102](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

---

## ‚ö° API Kernel: \`DPSequence\` (1D DP on sequences)
- **Kernel Contract**
  - **Inputs**: sequence; recurrence; base cases
  - **Outputs**: min/max count/value; number of ways
  - **Hooks**: \`transition(i, ...)\`, \`init_dp\`, \`answer(dp)\`
  - **Failure modes**: wrong base cases; $O(n^2)$ transitions without optimization
- **Core invariant**: \`dp[i]\` represents the optimal/total value for prefix ending at \`i\` (or length \`i\`)
- **Where you‚Äôll use this at work**
  - Cost optimization over time steps; simple planning/forecast recurrences
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 70](https://leetcode.com/problems/climbing-stairs/description/)
    - üî• [LeetCode 198](https://leetcode.com/problems/house-robber/description/)
    - üî• [LeetCode 322](https://leetcode.com/problems/coin-change/description/)
- **Patterns ‚Üí problems**
  - Fibonacci-style (\`dp_fibonacci_style\`)
    - [LeetCode 70](https://leetcode.com/problems/climbing-stairs/description/)
    - [LeetCode 198](https://leetcode.com/problems/house-robber/description/)
  - Knapsack-style (\`dp_knapsack\`)
    - [LeetCode 322](https://leetcode.com/problems/coin-change/description/)

---

## ‚ö° API Kernel: \`DPInterval\` (DP on ranges / intervals)
- **Kernel Contract**
  - **Inputs**: string/array; interval definition; fill order
  - **Outputs**: boolean/table, min cuts, max length, counts
  - **Hooks**: \`dp[l][r]\`, \`combine(subintervals)\`, iteration order by length
  - **Failure modes**: wrong fill order; $O(n^3)$ blowups without pruning/optimization
- **Core invariant**: \`dp[l][r]\` is correct once all smaller subintervals needed by its transition are computed
- **Where you‚Äôll use this at work**
  - Substring/range optimization where decisions split intervals
- **Must-know (üî•) / High-frequency (‚≠ê)**
  - **Must-know (üî•)**
    - üî• [LeetCode 1143](https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/)
- **Patterns ‚Üí problems**
  - Palindrome/interval DP (\`dp_palindrome\`)
    - [LeetCode 1143](https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/)

---

## üß≠ Roadmap Slices (from your data)
- **Recommended learning order (kernel sequence)**
  1) Hash map basics (\`HashMapLookup\`) + Two pointers/writer
  2) Sliding window
  3) Binary search (index boundary / answer space / partition index)
  4) Heap/top-k
  5) Linked list pointer patterns
  6) BFS/DFS (grid + trees)
  7) Backtracking
  8) (DP, Monotonic stack)
- **NeetCode 150 anchors (high ROI)**
  - Sliding window: [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
  - Two pointers: [LeetCode 11](https://leetcode.com/problems/container-with-most-water/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0011_container_with_most_water.py)
  - Backtracking: [LeetCode 39](https://leetcode.com/problems/combination-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0039_combination_sum.py)
  - Graph BFS: [LeetCode 994](https://leetcode.com/problems/rotting-oranges/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0994_rotting_oranges.py)
  - Heap/selection: [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0215_kth_largest_element_in_an_array.py)

---

## üèÅ ‚ÄúWhat next?‚Äù Mini Paths
- **Sliding Window Mastery (in order)**
  - [ ] [LeetCode 3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0003_longest_substring_without_repeating_characters.py)
  - [ ] [LeetCode 340](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0340_longest_substring_with_at_most_k_distinct.py)
  - [ ] [LeetCode 76](https://leetcode.com/problems/minimum-window-substring/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0076_minimum_window_substring.py)
  - [ ] [LeetCode 567](https://leetcode.com/problems/permutation-in-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0567_permutation_in_string.py)
  - [ ] [LeetCode 438](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0438_find_all_anagrams_in_a_string.py)
  - [ ] [LeetCode 209](https://leetcode.com/problems/minimum-size-subarray-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0209_minimum_size_subarray_sum.py)

- **Backtracking Mastery (in order)**
  - [ ] [LeetCode 78](https://leetcode.com/problems/subsets/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0078_subsets.py)
  - [ ] [LeetCode 90](https://leetcode.com/problems/subsets-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0090_subsets_ii.py)
  - [ ] [LeetCode 46](https://leetcode.com/problems/permutations/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0046_permutations.py)
  - [ ] [LeetCode 47](https://leetcode.com/problems/permutations-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0047_permutations_ii.py)
  - [ ] [LeetCode 39](https://leetcode.com/problems/combination-sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0039_combination_sum.py)
  - [ ] [LeetCode 40](https://leetcode.com/problems/combination-sum-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0040_combination_sum_ii.py)
  - [ ] [LeetCode 131](https://leetcode.com/problems/palindrome-partitioning/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0131_palindrome_partitioning.py)
  - [ ] [LeetCode 79](https://leetcode.com/problems/word-search/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0079_word_search.py)
  - [ ] [LeetCode 51](https://leetcode.com/problems/n-queens/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0051_n_queens.py)

- **Two Pointers Mastery (in order)**
  - [ ] [LeetCode 26](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0026_remove_duplicates_from_sorted_array.py)
  - [ ] [LeetCode 27](https://leetcode.com/problems/remove-element/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0027_remove_element.py)
  - [ ] [LeetCode 283](https://leetcode.com/problems/move-zeroes/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0283_move_zeroes.py)
  - [ ] [LeetCode 11](https://leetcode.com/problems/container-with-most-water/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0011_container_with_most_water.py)
  - [ ] [LeetCode 15](https://leetcode.com/problems/3sum/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0015_3sum.py)
  - [ ] [LeetCode 141](https://leetcode.com/problems/linked-list-cycle/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0141_linked_list_cycle.py)
  - [ ] [LeetCode 142](https://leetcode.com/problems/linked-list-cycle-ii/description/) | [Solution](https://github.com/lufftw/neetcode/blob/main/solutions/0142_linked_list_cycle_ii.py)`;
                    const { root } = transformer.transform(markdown);

                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    container.appendChild(svg);
                    const m = Markmap.create(svg, { color: (node) => node.payload?.color || '#f59e0b' }, root);
                    svg.mm = m;
                    m.fit();

                    // Attach toolbar if available
                    if (mm.Toolbar) {
                        const toolbar = new mm.Toolbar();
                        toolbar.attach(m);
                        setTimeout(function() {
                            document.querySelectorAll('.mm-toolbar').forEach(function(toolbar) {
                                toolbar.querySelectorAll('.mm-toolbar-item').forEach(function(item) {
                                    if ((item.title || '').toLowerCase().includes('dark')) item.remove();
                                });
                                var brand = toolbar.querySelector('.mm-toolbar-brand');
                                if (brand) {
                                    brand.innerHTML = 'üü° NeetCode';
                                    brand.href = '#'; brand.onclick = function(e) { e.preventDefault(); };
                                    brand.style.fontSize = '12px'; brand.style.color = '#666';
                                }
                            });
                        }, 200);
                    }
                } catch (error) {
                    console.error("Failed to initialize markmap:", error);
                }
            }

            // Utility functions for topbar buttons
            function fitView() {
                var svg = document.querySelector('.markmap > svg');
                if (svg && svg.mm) svg.mm.fit();
            }
            function expandAll() {
                var svg = document.querySelector('.markmap > svg');
                if (svg && svg.mm) {
                    var root = svg.mm.state.data;
                    (function expand(n) {
                        n.payload = Object.assign({}, n.payload, { fold: 0 });
                        if (n.children) n.children.forEach(expand);
                    })(root);
                    svg.mm.setData(root); svg.mm.fit();
                }
            }
            function collapseAll() {
                var svg = document.querySelector('.markmap > svg');
                if (svg && svg.mm) {
                    var root = svg.mm.state.data;
                    root.children && root.children.forEach(function collapse(n) {
                        if (n.children && n.children.length) {
                            n.payload = Object.assign({}, n.payload, { fold: 1 });
                            n.children.forEach(collapse);
                        }
                    });
                    svg.mm.setData(root); svg.mm.fit();
                }
            }

            // Make functions globally available
            window.fitView = fitView;
            window.expandAll = expandAll;
            window.collapseAll = collapseAll;

            // Expose init function for re-entry (for instant navigation)
            window.__initMindmap = initMindmap;

            // 1) Full page reload - initialize on DOMContentLoaded
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => initMindmap(), { once: true });
            } else {
                initMindmap();
            }

            // 2) MkDocs Material instant navigation (key lifecycle hook)
            if (window.document$ && typeof window.document$.subscribe === "function") {
                window.document$.subscribe(() => initMindmap());
            }

            // 3) Back/forward cache (BFCache) restoration
            window.addEventListener("pageshow", (e) => {
                if (e.persisted) initMindmap();
            });

            // 4) Additional PJAX/Instant Navigation event support
            document.addEventListener('pjax:end', initMindmap);
            document.addEventListener('pjax:success', initMindmap);
            document.addEventListener('turbolinks:load', initMindmap);
            document.addEventListener('swup:contentReplaced', initMindmap);
            document.addEventListener('swup:pageView', initMindmap);
        })();
    </script>
</head>
<body>
    <div id="topbar">
        <button onclick="fitView()">Fit View</button>
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>
    <div class="markmap"></div>
</body>
</html>