# Patterns - Problem-solving patterns that instantiate API Kernels
# Each pattern is a specific application of an API Kernel to a problem type.

# === Sliding Window Patterns ===
[[patterns]]
id = "sliding_window_unique"
api_kernel = "SubstringSlidingWindow"
summary = "Window where all elements are unique."

[[patterns]]
id = "sliding_window_at_most_k_distinct"
api_kernel = "SubstringSlidingWindow"
summary = "Window with at most K distinct elements."

[[patterns]]
id = "sliding_window_freq_cover"
api_kernel = "SubstringSlidingWindow"
summary = "Window must cover all required character frequencies."

[[patterns]]
id = "sliding_window_cost_bounded"
api_kernel = "SubstringSlidingWindow"
summary = "Window with sum/cost constraint."

[[patterns]]
id = "sliding_window_fixed_size"
api_kernel = "SubstringSlidingWindow"
summary = "Fixed-size sliding window."

# === Graph Traversal Patterns ===

# -- DFS Patterns --
[[patterns]]
id = "graph_dfs_connected_components"
api_kernel = "GraphDFS"
summary = "Count/identify connected components using DFS flood fill."

[[patterns]]
id = "graph_dfs_reachability"
api_kernel = "GraphDFS"
summary = "Check if target is reachable from source using DFS."

[[patterns]]
id = "graph_clone"
api_kernel = "GraphDFS"
summary = "Deep copy graph using DFS with old→new node mapping."

# -- BFS Patterns --
[[patterns]]
id = "graph_bfs_multi_source"
api_kernel = "GridBFSMultiSource"
summary = "Multi-source BFS for simultaneous propagation from multiple sources."

[[patterns]]
id = "graph_bfs_reachability"
api_kernel = "GraphBFS"
summary = "Check reachability using BFS traversal."

[[patterns]]
id = "graph_bfs_connected_components"
api_kernel = "GraphBFS"
summary = "Count connected components using BFS flood fill."

[[patterns]]
id = "grid_bfs_propagation"
api_kernel = "GridBFSMultiSource"
summary = "Layered BFS expansion from multiple sources on a grid."

[[patterns]]
id = "bfs_shortest_path"
api_kernel = "GridBFSMultiSource"
summary = "Find shortest path in unweighted graph using BFS."

[[patterns]]
id = "bfs_level_order"
api_kernel = "TreeTraversalBFS"
summary = "Process tree/graph level by level."

# -- Bipartite/Coloring --
[[patterns]]
id = "graph_bipartite"
api_kernel = "GraphBFS"
summary = "Check if graph is bipartite using two-coloring BFS/DFS."

# === Merge Patterns ===
[[patterns]]
id = "merge_k_sorted_heap"
api_kernel = "KWayMerge"
summary = "K-way merge using min-heap."

[[patterns]]
id = "merge_k_sorted_divide"
api_kernel = "KWayMerge"
summary = "K-way merge using divide-and-conquer."

[[patterns]]
id = "merge_two_sorted"
api_kernel = "KWayMerge"
summary = "Merge two sorted sequences."

# === Monotonic Stack Patterns ===
[[patterns]]
id = "next_greater_element"
api_kernel = "MonotonicStack"
summary = "Find next greater element for each position."

[[patterns]]
id = "next_smaller_element"
api_kernel = "MonotonicStack"
summary = "Find next smaller element for each position."

[[patterns]]
id = "monotonic_stack_circular"
api_kernel = "MonotonicStack"
summary = "Next greater/smaller with circular array (2n traversal)."

[[patterns]]
id = "histogram_max_rectangle"
api_kernel = "MonotonicStack"
summary = "Find largest rectangle in histogram using boundary expansion."

[[patterns]]
id = "maximal_rectangle_matrix"
api_kernel = "MonotonicStack"
summary = "Find maximal rectangle in binary matrix (row-by-row histogram)."

[[patterns]]
id = "monotonic_stack_span"
api_kernel = "MonotonicStack"
summary = "Count consecutive dominated elements (span calculation)."

[[patterns]]
id = "monotonic_stack_contribution"
api_kernel = "MonotonicStack"
summary = "Sum contributions using boundary products (subarray min/max sums)."

[[patterns]]
id = "monotonic_stack_container"
api_kernel = "MonotonicStack"
summary = "Water/container problems using valley resolution."

[[patterns]]
id = "monotonic_stack_greedy_selection"
api_kernel = "MonotonicStack"
summary = "Greedy optimal prefix selection (remove digits, create max number)."

[[patterns]]
id = "monotonic_stack_lexicographic"
api_kernel = "MonotonicStack"
summary = "Build lexicographically smallest/largest result."

# === Binary Search Patterns ===
[[patterns]]
id = "binary_search_first_true"
api_kernel = "BinarySearchBoundary"
summary = "Find first index where predicate becomes true."

[[patterns]]
id = "binary_search_last_true"
api_kernel = "BinarySearchBoundary"
summary = "Find last index where predicate is true."

[[patterns]]
id = "binary_search_lower_bound"
api_kernel = "BinarySearchBoundary"
summary = "Find first index where nums[i] >= target."

[[patterns]]
id = "binary_search_upper_bound"
api_kernel = "BinarySearchBoundary"
summary = "Find first index where nums[i] > target."

[[patterns]]
id = "binary_search_exact_match"
api_kernel = "BinarySearchBoundary"
summary = "Find exact value in sorted array or return not found."

[[patterns]]
id = "binary_search_insert_position"
api_kernel = "BinarySearchBoundary"
summary = "Find position where target should be inserted to maintain order."

[[patterns]]
id = "binary_search_on_answer"
api_kernel = "BinarySearchBoundary"
summary = "Binary search on answer space (minimize/maximize)."

[[patterns]]
id = "binary_search_minimize_maximum"
api_kernel = "BinarySearchBoundary"
summary = "Binary search to minimize the maximum value (capacity, time, etc.)."

[[patterns]]
id = "binary_search_maximize_minimum"
api_kernel = "BinarySearchBoundary"
summary = "Binary search to maximize the minimum value."

[[patterns]]
id = "binary_search_rotated"
api_kernel = "BinarySearchBoundary"
summary = "Binary search in rotated sorted array (distinct elements)."

[[patterns]]
id = "binary_search_rotated_duplicates"
api_kernel = "BinarySearchBoundary"
summary = "Binary search in rotated sorted array with duplicates."

[[patterns]]
id = "binary_search_peak_finding"
api_kernel = "BinarySearchBoundary"
summary = "Find peak element using slope direction detection."

# === Backtracking Patterns ===
[[patterns]]
id = "backtracking_permutation"
api_kernel = "BacktrackingExploration"
summary = "Generate all permutations with backtracking."

[[patterns]]
id = "backtracking_combination"
api_kernel = "BacktrackingExploration"
summary = "Generate all combinations with backtracking."

[[patterns]]
id = "backtracking_subset"
api_kernel = "BacktrackingExploration"
summary = "Generate all subsets with backtracking."

[[patterns]]
id = "backtracking_n_queens"
api_kernel = "BacktrackingExploration"
summary = "Place N queens on board with constraint checking."

[[patterns]]
id = "backtracking_sudoku"
api_kernel = "BacktrackingExploration"
summary = "Fill sudoku grid with constraint propagation."

[[patterns]]
id = "backtracking_combination_sum"
api_kernel = "BacktrackingExploration"
summary = "Find combinations that sum to target, with or without reuse."

[[patterns]]
id = "backtracking_combination_dedup"
api_kernel = "BacktrackingExploration"
summary = "Combinations with duplicate handling via same-level skip."

[[patterns]]
id = "backtracking_permutation_dedup"
api_kernel = "BacktrackingExploration"
summary = "Unique permutations with sorting and same-level deduplication."

[[patterns]]
id = "backtracking_subset_dedup"
api_kernel = "BacktrackingExploration"
summary = "Unique subsets with sorting and same-level deduplication."

[[patterns]]
id = "backtracking_string_segmentation"
api_kernel = "BacktrackingExploration"
summary = "Partition string into valid segments (IP, palindromes)."

[[patterns]]
id = "backtracking_grid_path"
api_kernel = "BacktrackingExploration"
summary = "DFS path search in grid with visited marking."

# === Linked List Patterns ===
[[patterns]]
id = "linked_list_k_group_reversal"
api_kernel = "LinkedListInPlaceReversal"
summary = "Reverse linked list in groups of K nodes."

[[patterns]]
id = "linked_list_full_reversal"
api_kernel = "LinkedListInPlaceReversal"
summary = "Reverse entire linked list."

[[patterns]]
id = "linked_list_partial_reversal"
api_kernel = "LinkedListInPlaceReversal"
summary = "Reverse portion of linked list between positions."

# === Two Pointer Patterns ===

# -- Opposite Pointers (Two-End) --
[[patterns]]
id = "two_pointer_opposite"
api_kernel = "TwoPointersTraversal"
summary = "Two pointers moving towards each other from opposite ends."

[[patterns]]
id = "two_pointer_opposite_search"
api_kernel = "TwoPointersTraversal"
summary = "Opposite pointers for searching pairs in sorted array."

[[patterns]]
id = "two_pointer_opposite_palindrome"
api_kernel = "TwoPointersTraversal"
summary = "Opposite pointers for symmetric/palindrome checks."

[[patterns]]
id = "two_pointer_opposite_maximize"
api_kernel = "TwoPointersTraversal"
summary = "Opposite pointers to maximize a function (e.g., container area)."

# -- Same-Direction (Writer Pattern) --
[[patterns]]
id = "two_pointer_same_direction"
api_kernel = "TwoPointersTraversal"
summary = "Two pointers moving in same direction (reader/writer)."

[[patterns]]
id = "two_pointer_writer_dedup"
api_kernel = "TwoPointersTraversal"
summary = "Reader/writer pattern for in-place deduplication."

[[patterns]]
id = "two_pointer_writer_remove"
api_kernel = "TwoPointersTraversal"
summary = "Reader/writer pattern for in-place element removal."

[[patterns]]
id = "two_pointer_writer_compact"
api_kernel = "TwoPointersTraversal"
summary = "Reader/writer pattern for array compaction (move zeroes)."

# -- Fast-Slow Pointers (Cycle Detection) --
[[patterns]]
id = "fast_slow_cycle_detect"
api_kernel = "FastSlowPointers"
summary = "Floyd's algorithm Phase 1: detect cycle existence."

[[patterns]]
id = "fast_slow_cycle_start"
api_kernel = "FastSlowPointers"
summary = "Floyd's algorithm Phase 2: find cycle start node."

[[patterns]]
id = "fast_slow_midpoint"
api_kernel = "FastSlowPointers"
summary = "Fast-slow pointers to find midpoint of linked list."

[[patterns]]
id = "fast_slow_implicit_cycle"
api_kernel = "FastSlowPointers"
summary = "Cycle detection on implicit sequence (e.g., Happy Number)."

# -- Partitioning / Dutch National Flag --
[[patterns]]
id = "dutch_flag_partition"
api_kernel = "TwoPointerPartition"
summary = "Three-way partition (Dutch national flag)."

[[patterns]]
id = "two_way_partition"
api_kernel = "TwoPointerPartition"
summary = "Two-way partition (even/odd, positive/negative)."

[[patterns]]
id = "quickselect_partition"
api_kernel = "TwoPointerPartition"
summary = "Partition-based selection for Kth element."

# -- Dedup + Sorted Enumeration (Multi-Sum) --
[[patterns]]
id = "two_pointer_three_sum"
api_kernel = "TwoPointersTraversal"
summary = "Sorted array 3Sum with deduplication."

[[patterns]]
id = "two_pointer_k_sum"
api_kernel = "TwoPointersTraversal"
summary = "Generalized k-Sum using nested two-pointer search."

# -- Merge Pattern --
[[patterns]]
id = "merge_two_sorted_lists"
api_kernel = "MergeSortedSequences"
summary = "Merge two sorted linked lists."

[[patterns]]
id = "merge_two_sorted_arrays"
api_kernel = "MergeSortedSequences"
summary = "Merge two sorted arrays (in-place or new array)."

[[patterns]]
id = "merge_sorted_from_ends"
api_kernel = "MergeSortedSequences"
summary = "Merge by comparing from ends (e.g., squares of sorted array)."

# === DP Patterns ===
[[patterns]]
id = "dp_fibonacci_style"
api_kernel = "DPSequence"
summary = "DP with simple recurrence like Fibonacci."

[[patterns]]
id = "dp_longest_increasing"
api_kernel = "DPSequence"
summary = "Longest increasing subsequence pattern."

[[patterns]]
id = "dp_knapsack"
api_kernel = "DPSequence"
summary = "0/1 knapsack and variants."

[[patterns]]
id = "dp_palindrome"
api_kernel = "DPInterval"
summary = "Palindrome-related DP (longest, count, etc.)."

# === Tree Patterns ===

# -- DFS Traversal Orders --
[[patterns]]
id = "tree_dfs_recursive"
api_kernel = "TreeTraversalDFS"
summary = "Recursive DFS on tree."

[[patterns]]
id = "tree_dfs_iterative"
api_kernel = "TreeTraversalDFS"
summary = "Iterative DFS using explicit stack."

[[patterns]]
id = "tree_dfs_inorder"
api_kernel = "TreeTraversalDFS"
summary = "Inorder traversal: Left → Node → Right. BST gives sorted order."

[[patterns]]
id = "tree_dfs_preorder"
api_kernel = "TreeTraversalDFS"
summary = "Preorder traversal: Node → Left → Right. Copy/serialize tree."

[[patterns]]
id = "tree_dfs_postorder"
api_kernel = "TreeTraversalDFS"
summary = "Postorder traversal: Left → Right → Node. Delete tree, compute subtree values."

# -- BFS Patterns --
[[patterns]]
id = "tree_bfs_level_order"
api_kernel = "TreeTraversalBFS"
summary = "Level-order traversal using queue with level-size batching."

# -- Property Patterns --
[[patterns]]
id = "tree_property_computation"
api_kernel = "TreeTraversalDFS"
summary = "Compute tree properties (height, depth, node count) recursively."

[[patterns]]
id = "tree_property_validation"
api_kernel = "TreeTraversalDFS"
summary = "Validate tree properties with early termination using sentinel values."

# -- Path Patterns --
[[patterns]]
id = "tree_path_computation"
api_kernel = "TreeTraversalDFS"
summary = "Compute path metrics (diameter, longest path) with return-vs-update pattern."

[[patterns]]
id = "tree_path_sum"
api_kernel = "TreeTraversalDFS"
summary = "Track path sums, skipping negative subtrees with max(0, gain)."

# === Heap Patterns ===
[[patterns]]
id = "heap_top_k"
api_kernel = "HeapTopK"
summary = "Find/maintain top K elements."

[[patterns]]
id = "heap_kth_element"
api_kernel = "HeapTopK"
summary = "Find Kth largest/smallest element."

[[patterns]]
id = "heap_median_stream"
api_kernel = "HeapTopK"
summary = "Maintain median of data stream using two heaps."

[[patterns]]
id = "heap_interval_scheduling"
api_kernel = "HeapTopK"
summary = "Min-heap of end times for interval/meeting room scheduling."

[[patterns]]
id = "heap_task_scheduler"
api_kernel = "HeapTopK"
summary = "Greedy scheduling with max-heap and cooldown constraint."

[[patterns]]
id = "heap_greedy_simulation"
api_kernel = "HeapTopK"
summary = "Repeatedly process largest/smallest element in simulation."

# === Union Find Patterns ===
[[patterns]]
id = "union_find_connected_components"
api_kernel = "UnionFindConnectivity"
summary = "Count/identify connected components."

[[patterns]]
id = "union_find_cycle_detection"
api_kernel = "UnionFindConnectivity"
summary = "Detect cycle in undirected graph."

# === Prefix Sum Patterns ===
[[patterns]]
id = "prefix_sum_range_query"
api_kernel = "PrefixSumRangeQuery"
summary = "Answer range sum queries in O(1)."

[[patterns]]
id = "prefix_sum_subarray_sum"
api_kernel = "PrefixSumSubarraySum"
summary = "Find/count subarrays with target sum using prefix sum + hash map."

[[patterns]]
id = "prefix_sum_transform"
api_kernel = "PrefixSumSubarraySum"
summary = "Transform problem (e.g., 0->-1) then find subarray with sum=0."

[[patterns]]
id = "prefix_sum_modular_arithmetic"
api_kernel = "PrefixSumSubarraySum"
summary = "Find subarrays with sum divisible by k using prefix sum modulo."

[[patterns]]
id = "prefix_sum_2d"
api_kernel = "PrefixSum2D"
summary = "2D prefix sum for rectangle sum queries using inclusion-exclusion."

[[patterns]]
id = "prefix_suffix_product"
api_kernel = "PrefixProduct"
summary = "Prefix and suffix products for product-except-self problems."

[[patterns]]
id = "difference_array"
api_kernel = "DifferenceArray"
summary = "Range update operations using difference array (inverse of prefix sum)."

# === Interval Patterns ===
[[patterns]]
id = "interval_merge"
api_kernel = "IntervalMerge"
summary = "Sort by start, merge adjacent overlapping intervals."

[[patterns]]
id = "interval_insert"
api_kernel = "IntervalMerge"
summary = "Insert new interval into sorted list using three-phase processing."

[[patterns]]
id = "interval_scheduling"
api_kernel = "IntervalScheduling"
summary = "Sort by end, greedily select maximum non-overlapping intervals."

[[patterns]]
id = "interval_intersection"
api_kernel = "IntervalMerge"
summary = "Two-pointer merge to find intersections of two sorted interval lists."

# === Union-Find Patterns ===
[[patterns]]
id = "union_find_connected_components"
api_kernel = "UnionFindConnectivity"
summary = "Count or identify connected components using Union-Find."

[[patterns]]
id = "union_find_cycle_detection"
api_kernel = "UnionFindConnectivity"
summary = "Detect cycle by checking if union connects already-connected nodes."

[[patterns]]
id = "union_find_equivalence_grouping"
api_kernel = "UnionFindConnectivity"
summary = "Group items by transitive equivalence (shared elements)."

[[patterns]]
id = "union_find_constraint_satisfaction"
api_kernel = "UnionFindConnectivity"
summary = "Check satisfiability of equality/inequality constraints."

# === Greedy Core Patterns ===
[[patterns]]
id = "reachability"
api_kernel = "GreedyCore"
summary = "Track farthest reachable position with single-pass greedy."

[[patterns]]
id = "min_jumps"
api_kernel = "GreedyCore"
summary = "Count minimum jumps using BFS-like level traversal with reachability."

[[patterns]]
id = "prefix_min_reset"
api_kernel = "GreedyCore"
summary = "Track prefix deficit with candidate reset on negative balance."

[[patterns]]
id = "two_pass_greedy"
api_kernel = "GreedyCore"
summary = "Two-pass greedy to satisfy bidirectional constraints."

[[patterns]]
id = "sort_match"
api_kernel = "GreedyCore"
summary = "Sort both sequences then greedily match elements."

[[patterns]]
id = "cost_difference"
api_kernel = "GreedyCore"
summary = "Sort by cost difference to optimize assignment decisions."

# === DP 1D Linear Patterns ===
[[patterns]]
id = "fibonacci_style"
api_kernel = "DP1DLinear"
summary = "Count ways using Fibonacci-like recurrence dp[i] = dp[i-1] + dp[i-2]."

[[patterns]]
id = "count_ways"
api_kernel = "DP1DLinear"
summary = "Count distinct ways to reach a state."

[[patterns]]
id = "min_cost_path"
api_kernel = "DP1DLinear"
summary = "Minimize cost to reach goal using dp[i] = min(dp[i-1], dp[i-2]) + cost[i]."

[[patterns]]
id = "include_exclude"
api_kernel = "DP1DLinear"
summary = "Choose to include or exclude element: dp[i] = max(dp[i-1], dp[i-2] + val[i])."

[[patterns]]
id = "max_non_adjacent"
api_kernel = "DP1DLinear"
summary = "Maximum sum of non-adjacent elements."

[[patterns]]
id = "circular_decomposition"
api_kernel = "DP1DLinear"
summary = "Decompose circular array into two linear subproblems."

[[patterns]]
id = "running_min_max"
api_kernel = "DP1DLinear"
summary = "Track running minimum/maximum for optimal decision."

[[patterns]]
id = "kadane_style"
api_kernel = "DP1DLinear"
summary = "Kadane's algorithm style for max subarray/profit problems."

# === DP Knapsack/Subset Patterns ===
[[patterns]]
id = "knapsack_01_boolean"
api_kernel = "DPKnapsackSubset"
summary = "0/1 Knapsack to check if target sum is achievable."

[[patterns]]
id = "knapsack_01_count"
api_kernel = "DPKnapsackSubset"
summary = "0/1 Knapsack to count ways to achieve target sum."

[[patterns]]
id = "target_transformation"
api_kernel = "DPKnapsackSubset"
summary = "Transform +/- assignment to subset sum via algebraic manipulation."

[[patterns]]
id = "unbounded_knapsack_min"
api_kernel = "DPKnapsackSubset"
summary = "Unbounded knapsack to minimize items needed for target."

[[patterns]]
id = "unbounded_knapsack_count"
api_kernel = "DPKnapsackSubset"
summary = "Unbounded knapsack to count combinations (coins outer loop)."

# === Math / Number Theory Patterns ===
[[patterns]]
id = "gcd_euclidean"
api_kernel = "MathNumberTheory"
summary = "GCD using Euclidean algorithm: gcd(a,b) = gcd(b, a%b)."

[[patterns]]
id = "prime_sieve"
api_kernel = "MathNumberTheory"
summary = "Sieve of Eratosthenes for prime counting/listing."

[[patterns]]
id = "base_conversion"
api_kernel = "MathNumberTheory"
summary = "Convert between number bases with mod and divide."

# === Segment Tree / Fenwick Tree Patterns ===
[[patterns]]
id = "range_sum_update"
api_kernel = "SegmentTreeFenwick"
summary = "Range sum queries with point updates using BIT or Segment Tree."

[[patterns]]
id = "fenwick_tree"
api_kernel = "SegmentTreeFenwick"
summary = "Fenwick Tree (BIT) for prefix sum and point update in O(log n)."

[[patterns]]
id = "segment_tree"
api_kernel = "SegmentTreeFenwick"
summary = "Segment Tree for flexible range queries (sum, min, max) with updates."

[[patterns]]
id = "count_inversions"
api_kernel = "SegmentTreeFenwick"
summary = "Count inversions using BIT with coordinate compression."

[[patterns]]
id = "merge_sort_counting"
api_kernel = "SegmentTreeFenwick"
summary = "Count pairs/inversions during merge sort."

[[patterns]]
id = "coordinate_compression"
api_kernel = "SegmentTreeFenwick"
summary = "Map large value range to small rank range for BIT usage."

# ===== Line Sweep Patterns =====

[[patterns]]
id = "line_sweep_event_counting"
api_kernel = "LineSweep"
summary = "Count overlapping intervals using +1/-1 events."

[[patterns]]
id = "line_sweep_capacity_tracking"
api_kernel = "LineSweep"
summary = "Track capacity/load across positions using weighted events."

[[patterns]]
id = "line_sweep_height_tracking"
api_kernel = "LineSweep"
summary = "Track maximum height using heap or sorted container."

[[patterns]]
id = "difference_array_sweep"
api_kernel = "LineSweep"
summary = "Offline range updates using difference array and prefix sum."

# ===== Tree DP Patterns =====

[[patterns]]
id = "tree_dp_include_exclude"
api_kernel = "TreeDP"
summary = "Binary choice per node: track (with_node, without_node) states."

[[patterns]]
id = "tree_dp_path_contribution"
api_kernel = "TreeDP"
summary = "Path optimization: return single-branch contribution, track global max."

[[patterns]]
id = "tree_dp_multi_state"
api_kernel = "TreeDP"
summary = "Multiple states per node for coverage/coloring constraints."

[[patterns]]
id = "tree_dp_coverage"
api_kernel = "TreeDP"
summary = "Minimum coverage problems: cameras, dominators, vertex cover."

# ===== Bitmask DP Patterns =====

[[patterns]]
id = "bitmask_dp_enumeration"
api_kernel = "BitmaskDP"
summary = "Generate all subsets by iterating bitmasks 0 to 2^n-1."

[[patterns]]
id = "bitmask_dp_bfs"
api_kernel = "BitmaskDP"
summary = "BFS with (node, visited_mask) state for TSP-style problems."

[[patterns]]
id = "bitmask_dp_set_cover"
api_kernel = "BitmaskDP"
summary = "Minimum items to cover all requirements using dp[mask]."

[[patterns]]
id = "bitmask_dp_tsp"
api_kernel = "BitmaskDP"
summary = "TSP-style DP: dp[mask][last] for min cost visiting all nodes."

# ===== String DP Patterns =====

[[patterns]]
id = "string_dp_lcs"
api_kernel = "StringDP"
summary = "Longest Common Subsequence: dp[i][j] = LCS of s[0:i] and t[0:j]."

[[patterns]]
id = "string_dp_edit_distance"
api_kernel = "StringDP"
summary = "Edit Distance: min operations (insert, delete, replace) to transform."

[[patterns]]
id = "string_dp_palindrome"
api_kernel = "StringDP"
summary = "Longest Palindromic Subsequence via LCS(s, reverse(s))."

[[patterns]]
id = "string_dp_matching"
api_kernel = "StringDP"
summary = "Regex/wildcard matching with . and * patterns."

# ===== Monotonic Deque Patterns =====

[[patterns]]
id = "monotonic_deque_sliding_max"
api_kernel = "MonotonicDeque"
summary = "Sliding window maximum using decreasing deque of indices."

[[patterns]]
id = "monotonic_deque_bounded_range"
api_kernel = "MonotonicDeque"
summary = "Longest subarray with bounded min-max difference using two deques."

[[patterns]]
id = "monotonic_deque_prefix_sum"
api_kernel = "MonotonicDeque"
summary = "Shortest subarray with sum >= k using prefix sums and monotonic deque."

[[patterns]]
id = "monotonic_deque_optimization"
api_kernel = "MonotonicDeque"
summary = "Optimize equations by decomposing into x-dependent and x-independent parts."

# ===== Interval DP Patterns =====

[[patterns]]
id = "interval_dp_burst"
api_kernel = "IntervalDP"
summary = "Burst balloons style: think 'last to burst', add boundary elements."

[[patterns]]
id = "interval_dp_polygon"
api_kernel = "IntervalDP"
summary = "Polygon triangulation: choose third vertex for each edge."

[[patterns]]
id = "interval_dp_cut"
api_kernel = "IntervalDP"
summary = "Cut stick style: sort cuts, add boundaries, think 'last cut'."

[[patterns]]
id = "interval_dp_printer"
api_kernel = "IntervalDP"
summary = "Strange printer: character matching optimization, extend print when chars match."

# ===== String Matching Patterns =====

[[patterns]]
id = "string_matching_kmp"
api_kernel = "StringMatching"
summary = "KMP algorithm: build failure function, use for substring search in O(n+m)."

[[patterns]]
id = "string_matching_rabin_karp"
api_kernel = "StringMatching"
summary = "Rabin-Karp: rolling hash for pattern search, verify on collision."

[[patterns]]
id = "string_matching_kmp_concatenation"
api_kernel = "StringMatching"
summary = "KMP on concatenated strings (s + '#' + reverse(s)) for palindrome prefix."

[[patterns]]
id = "string_matching_kmp_period"
api_kernel = "StringMatching"
summary = "Period detection: period = n - failure[n-1], check divisibility."

[[patterns]]
id = "string_matching_kmp_direct"
api_kernel = "StringMatching"
summary = "Direct failure function application for longest prefix-suffix."
